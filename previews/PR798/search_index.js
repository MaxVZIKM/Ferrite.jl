var documenterSearchIndex = {"docs":
[{"location":"reference/utils/","page":"Development utility functions","title":"Development utility functions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/utils/#Development-utility-functions","page":"Development utility functions","title":"Development utility functions","text":"","category":"section"},{"location":"reference/utils/","page":"Development utility functions","title":"Development utility functions","text":"Ferrite.debug_mode","category":"page"},{"location":"reference/utils/#Ferrite.debug_mode","page":"Development utility functions","title":"Ferrite.debug_mode","text":"Ferrite.debug_mode(; enable=true)\n\nHelper to turn on (enable=true) or off (enable=false) debug expressions in Ferrite.\n\nDebug mode influences Ferrite.@debug expr: when debug mode is enabled, expr is evaluated, and when debug mode is disabled expr is ignored.\n\n\n\n\n\n","category":"function"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<div class=\"citation canonical\"><dl><dt>[1]</dt>\n<dd>\n<div id=\"Turcksin2016\">B. Turcksin, M. Kronbichler and W. Bangerth. <a href='https://doi.org/10.1145/2851488'><i>WorkStream ‚Äì A Design Pattern for Multicore-Enabled Finite Element Computations</i></a>. <a href='https://doi.org/10.1145/2851488'>ACM Trans. Math. Softw. <b>43</b> (2016)</a>.</div>\n</dd><dt>[2]</dt>\n<dd>\n<div id=\"Cenanovic2017\">M. Cenanovic. <i>Finite element methods for surface problems</i>. Phd thesis, J√∏pk√∏ping University, School of Engineering (2017).</div>\n</dd><dt>[3]</dt>\n<dd>\n<div id=\"Scroggs2022\">M. W. Scroggs, J. S. Dokken, C. N. Richardson and G. N. Wells. <a href='https://doi.org/10.1145/3524456'><i>Construction of Arbitrary Order Finite Element Degree-of-Freedom Maps on Polygonal and Polyhedral Cell Meshes</i></a>. <a href='https://doi.org/10.1145/3524456'>ACM Trans. Math. Softw. <b>48</b> (2022)</a>.</div>\n</dd>\n</dl></div>","category":"page"},{"location":"references/","page":"References","title":"References","text":"<!--","category":"page"},{"location":"references/","page":"References","title":"References","text":"Workaround for https://github.com/JuliaDocs/DocumenterCitations.jl/issues/39","category":"page"},{"location":"references/","page":"References","title":"References","text":"[1]\n[2]\n[3]","category":"page"},{"location":"references/","page":"References","title":"References","text":"-->","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Here you can find some documentation of the internals of Ferrite.jl which are useful when developing the library.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Depth = 1\nPages = [\"reference_cells.md\", \"interpolations.md\", \"elements.md\", \"mapping.md\", \"dofhandler.md\", \"performance.md\"]","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"EditURL = \"../literate-tutorials/maxwell.jl\"","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"Maxwell's equations For simplicity, we start with the very basic example from https://www.math.colostate.edu/~bangerth/videos.676.33.html Specifically,","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"int_Omega leftmathrmcurl(boldsymboldelta u) cdot mathrmcurl(boldsymbolu)\n+ mathrmdiv(boldsymboldelta u) mathrmdiv(boldsymbolu)right mathrmdOmega = 0","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"As noted in the lecture, standard Lagrange elements are not sufficient to solve this problem accurately, and we therefore use the Nedelec interpolation.","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"import LinearAlgebra: normalize\nusing StaticArrays\nusing Test\nusing Ferrite\nimport Ferrite: Nedelec, RaviartThomas\nimport CairoMakie as M\nip = Nedelec{2,RefTriangle,2}()\nip = RaviartThomas{2,RefTriangle,1}()\ngrid = generate_grid(Triangle, (1,2))\ndh = DofHandler(grid)\nadd!(dh, :B, ip)\nclose!(dh)\n\nip_geo = Ferrite.default_interpolation(Triangle)\nqr = QuadratureRule{RefTriangle}(10)\n\nqr_points = Vec{2,Float64}[]; n=6\nappend!(qr_points, [Vec((0.0, i/(n+1))) for i in 1:n])\nappend!(qr_points, [Vec((i/(n+1), 0.0)) for i in 1:n])\nappend!(qr_points, [Vec((i/(n+1), 1 - i/(n+1))) for i in 1:n])\nqr = QuadratureRule{RefTriangle}(zeros(length(qr_points)), qr_points)\ncv = CellValues(qr, ip, ip_geo)\n\nfunction plot_shapes(dh, cv)\n    grid = dh.grid\n    n_qp = getncells(grid)*getnquadpoints(cv)\n    coords = (zeros(n_qp), zeros(n_qp))\n    vectors = (zeros(n_qp), zeros(n_qp))\n\n    for nr in 1:(ndofs(dh))\n        u = zeros(ndofs(dh))\n        u[nr] = 1.0\n\n        for cell_nr in 1:getncells(grid)\n            x = getcoordinates(grid, cell_nr)\n            reinit!(cv, x, getcells(grid, cell_nr))\n            ue = u[celldofs(dh, cell_nr)]\n            for q_point in 1:getnquadpoints(cv)\n                i = getnquadpoints(cv)*(cell_nr-1) + q_point\n                qp_x = spatial_coordinate(cv, q_point, x)\n                v = function_value(cv, q_point, ue)\n                sfac = norm(v) ‚âà 0 ? NaN : 1.0 # Skip plotting zero-vector points\n                coords[1][i] = sfac*qp_x[1]\n                coords[2][i] = sfac*qp_x[2]\n                vectors[1][i] = v[1]\n                vectors[2][i] = v[2]\n            end\n        end\n\n        fig = M.Figure()\n        ax = M.Axis(fig[1,1]; aspect=M.DataAspect())\n        for cellnr in 1:getncells(grid)\n            x = getcoordinates(grid, cellnr)\n            push!(x, x[1])\n            M.lines!(ax, first.(x), last.(x), color=:black)\n        end\n        M.arrows!(ax, coords..., vectors...; lengthscale=0.1)\n        display(fig)\n    end\n    return nothing\nend\nplot_shapes(dh, cv)","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"","category":"page"},{"location":"tutorials/maxwell/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"devdocs/reference_cells/#Reference-cells","page":"Reference cells","title":"Reference cells","text":"","category":"section"},{"location":"devdocs/reference_cells/","page":"Reference cells","title":"Reference cells","text":"The reference cells are used to i) define grid cells, ii) define shape functions, and iii) define quadrature rules. The numbering of vertices, edges, faces are visualized below. See also FerriteViz.elementinfo.","category":"page"},{"location":"devdocs/reference_cells/#AbstractRefShape-subtypes","page":"Reference cells","title":"AbstractRefShape subtypes","text":"","category":"section"},{"location":"devdocs/reference_cells/","page":"Reference cells","title":"Reference cells","text":"Ferrite.AbstractRefShape\nFerrite.RefLine\nFerrite.RefTriangle\nFerrite.RefQuadrilateral\nFerrite.RefTetrahedron\nFerrite.RefHexahedron\nFerrite.RefPrism","category":"page"},{"location":"devdocs/reference_cells/#Ferrite.AbstractRefShape","page":"Reference cells","title":"Ferrite.AbstractRefShape","text":"AbstractRefShape{refdim}\n\nSupertype for all reference shapes, with reference dimension refdim. Reference shapes are used to define grid cells, shape functions, and quadrature rules. Currently existing reference shapes are: RefLine, RefTriangle, RefQuadrilateral, RefTetrahedron, RefHexahedron, RefPrism.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefLine","page":"Reference cells","title":"Ferrite.RefLine","text":"RefLine <: AbstractRefShape{1}\n\nReference line/interval, reference dimension 1.\n\n----------------+--------------------\nVertex numbers: | Vertex coordinates:\n  1-------2     | v1: ùõè = (-1.0,)\n    --> Œæ‚ÇÅ      | v2: ùõè = ( 1.0,)\n----------------+--------------------\nFace numbers:   | Face identifiers:\n  1-------2     | f1: (v1,)\n                | f2: (v2,)\n----------------+--------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefTriangle","page":"Reference cells","title":"Ferrite.RefTriangle","text":"RefTriangle <: AbstractRefShape{2}\n\nReference triangle, reference dimension 2.\n\n----------------+--------------------\nVertex numbers: | Vertex coordinates:\n    2           |\n    | \\         | v1: ùõè = (1.0, 0.0)\n    |   \\       | v2: ùõè = (0.0, 1.0)\nŒæ‚ÇÇ^ |     \\     | v3: ùõè = (0.0, 0.0)\n  | 3-------1   |\n  +--> Œæ‚ÇÅ       |\n----------------+--------------------\nFace numbers:   | Face identifiers:\n    +           |\n    | \\         | f1: (v1, v2)\n    2   1       | f2: (v2, v3)\n    |     \\     | f3: (v3, v1)\n    +---3---+   |\n----------------+--------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefQuadrilateral","page":"Reference cells","title":"Ferrite.RefQuadrilateral","text":"RefQuadrilateral <: AbstractRefShape{2}\n\nReference quadrilateral, reference dimension 2.\n\n----------------+---------------------\nVertex numbers: | Vertex coordinates:\n    4-------3   |\n    |       |   | v1: ùõè = (-1.0, -1.0)\n    |       |   | v2: ùõè = ( 1.0, -1.0)\nŒæ‚ÇÇ^ |       |   | v3: ùõè = ( 1.0,  1.0)\n  | 1-------2   | v4: ùõè = (-1.0,  1.0)\n  +--> Œæ‚ÇÅ       |\n----------------+---------------------\nFace numbers:   | Face identifiers:\n    +---3---+   | f1: (v1, v2)\n    |       |   | f2: (v2, v3)\n    4       2   | f3: (v3, v4)\n    |       |   | f4: (v4, v1)\n    +---1---+   |\n----------------+---------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefTetrahedron","page":"Reference cells","title":"Ferrite.RefTetrahedron","text":"RefTetrahedron <: AbstractRefShape{3}\n\nReference tetrahedron, reference dimension 3.\n\n---------------------------------------+-------------------------\nVertex numbers:                        | Vertex coordinates:\n             4                4        |\n  ^ Œæ‚ÇÉ      /  \\             /| \\      |  v1: ùõè = (0.0, 0.0, 0.0)\n  |        /     \\          / |   \\    |  v2: ùõè = (1.0, 0.0, 0.0)\n  +-> Œæ‚ÇÇ  /        \\       /  1___  \\  |  v3: ùõè = (0.0, 1.0, 0.0)\n /       /      __--3     / /    __‚Äæ-3 |  v4: ùõè = (0.0, 0.0, 1.0)\nŒæ‚ÇÅ      2 __--‚Äæ‚Äæ         2/__--‚Äæ‚Äæ      |\n---------------------------------------+-------------------------\nEdge numbers:                          | Edge identifiers:\n             +                +        | e1: (v1, v2)\n            /  \\             /| \\      | e2: (v2, v3)\n         5 /     \\ 6      5 / |4  \\ 6  | e3: (v3, v1)\n          /        \\       /  +__3  \\  | e4: (v1, v4)\n         /      __--+     / /1   __‚Äæ-+ | e5: (v2, v4)\n        + __--‚Äæ‚Äæ2        +/__--‚Äæ‚Äæ2     | e6: (v3, v4)\n---------------------------------------+-------------------------\nFace numbers:                          | Face identifiers:\n             +                +        |\n            /  \\             /| \\      | f1: (v1, v3, v2)\n           /     \\          / | 4 \\    | f2: (v1, v2, v4)\n          /   3    \\       /2 +___  \\  | f3: (v2, v3, v4)\n         /      __--+     / /  1 __‚Äæ-+ | f4: (v1, v4, v3)\n        + __--‚Äæ‚Äæ         +/__--‚Äæ‚Äæ      |\n---------------------------------------+-------------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefHexahedron","page":"Reference cells","title":"Ferrite.RefHexahedron","text":"RefHexahedron <: AbstractRefShape{3}\n\nReference hexahedron, reference dimension 3.\n\n-----------------------------------------+----------------------------\nVertex numbers:                          | Vertex coordinates:\n            5--------8        5--------8 | v1: ùõè = (-1.0, -1.0, -1.0)\n           /        /|       /|        | | v2: ùõè = ( 1.0, -1.0, -1.0)\n          /        / |      / |        | | v3: ùõè = ( 1.0,  1.0, -1.0)\n  ^ Œæ‚ÇÉ   6--------7  |     6  |        | | v4: ùõè = (-1.0,  1.0, -1.0)\n  |      |        |  4     |  1--------4 | v5: ùõè = (-1.0, -1.0,  1.0)\n  +-> Œæ‚ÇÇ |        | /      | /        /  | v6: ùõè = ( 1.0, -1.0,  1.0)\n /       |        |/       |/        /   | v7: ùõè = ( 1.0,  1.0,  1.0)\nŒæ‚ÇÅ       2--------3        2--------3    | v8: ùõè = (-1.0,  1.0,  1.0)\n-----------------------------------------+-----------------------------\nEdge numbers:                            | Edge identifiers:\n            +----8---+        +----8---+ |\n          5/        /|      5/|        | |  e1: (v1, v2),  e2: (v2, v3)\n          /       7/ |12    / |9     12| |  e3: (v3, v4),  e4: (v4, v1)\n         +----6---+  |     +  |        | |  e5: (v5, v6),  e6: (v6, v7)\n         |        |  +     |  +---4----+ |  e7: (v7, v8),  e8: (v8, v5)\n       10|      11| /    10| /1       /  |  e9: (v1, v5), e10: (v2, v6)\n         |        |/3      |/        /3  | e11: (v3, v7), e12: (v4, v8)\n         +---2----+        +---2----+    |\n-----------------------------------------+-----------------------------\nFace numbers:                            | Face identifiers:\n            +--------+        +--------+ |\n           /   6    /|       /|        | |  f1: (v1, v4, v3, v2)\n          /        / |      / |   5    | |  f2: (v1, v2, v6, v5)\n         +--------+ 4|     +  |        | |  f3: (v2, v3, v7, v6)\n         |        |  +     |2 +--------+ |  f4: (v3, v4, v8, v7)\n         |    3   | /      | /        /  |  f5: (v1, v5, v8, v4)\n         |        |/       |/    1   /   |  f6: (v5, v6, v7, v8)\n         +--------+        +--------+    |\n-----------------------------------------+-----------------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/reference_cells/#Ferrite.RefPrism","page":"Reference cells","title":"Ferrite.RefPrism","text":"RefPrism <: AbstractRefShape{3}\n\nReference prism, reference dimension 3.\n\n-----------------------------------------+----------------------------\nVertex numbers:                          | Vertex coordinates:\n            4-------/6       4--------6  |\n           /     /   |      /|        |  |  v1: ùõè = (0.0, 0.0, 0.0)\n          /   /      |     / |        |  |  v2: ùõè = (1.0, 0.0, 0.0)\n  ^ Œæ‚ÇÉ   5 /         |    5  |        |  |  v3: ùõè = (0.0, 1.0, 0.0)\n  |      |          /3    |  1-------/3  |  v4: ùõè = (0.0, 0.0, 1.0)\n  +-> Œæ‚ÇÇ |       /        | /     /      |  v5: ùõè = (1.0, 0.0, 1.0)\n /       |    /           |/   /         |  v6: ùõè = (0.0, 1.0, 1.0)\nŒæ‚ÇÅ       2 /              2 /            |\n-----------------------------------------+----------------------------\nEdge numbers:                            | Edge identifiers:\n            +---8---/+       +---8----+  |\n          7/     /   |     7/|        |  | e1: (v2, v1),  e2: (v1, v3)\n          /   / 9    |6    / |3       |6 | e3: (v1, v4),  e4: (v3, v2)\n         + /         |    +  |        |  | e5: (v2, v5),  e6: (v3, v6)\n         |          /+    |  +--2----/+  | e7: (v4, v5),  e8: (v4, v6)\n        5|       /       5| /1    /      | e9: (v6, v5)\n         |    / 4         |/   / 4       |\n         + /              + /            |\n-----------------------------------------+----------------------------\nFace numbers:                            | Face identifiers:\n            +-------/+       +--------+  |\n           /  5  /   |      /|        |  | f1: (v1, v3, v2)\n          /   /      |     / |    3   |  | f2: (v1, v2, v5, v4)\n         + /         |    +  |        |  | f3: (v3, v1, v4, v6)\n         |     4    /+    |2 +-------/+  | f4: (v2, v3, v6, v5)\n         |       /        | /  1  /      | f5: (v4, v5, v6)\n         |    /           |/   /         |\n         + /              + /            |\n-----------------------------------------+----------------------------\n\n\n\n\n\n","category":"type"},{"location":"devdocs/interpolations/#devdocs-interpolations","page":"Interpolations","title":"Interpolations","text":"","category":"section"},{"location":"devdocs/interpolations/#Type-definitions","page":"Interpolations","title":"Type definitions","text":"","category":"section"},{"location":"devdocs/interpolations/","page":"Interpolations","title":"Interpolations","text":"Interpolations are subtypes of Interpolation{shape, order}, i.e. they are parametrized by the reference element and its characteristic order.","category":"page"},{"location":"devdocs/interpolations/#Fallback-methods-applicable-for-all-subtypes-of-Interpolation","page":"Interpolations","title":"Fallback methods applicable for all subtypes of Interpolation","text":"","category":"section"},{"location":"devdocs/interpolations/","page":"Interpolations","title":"Interpolations","text":"Ferrite.getdim(::Interpolation)\nFerrite.getrefshape(::Interpolation)\nFerrite.getorder(::Interpolation)\nFerrite.shape_gradient(::Interpolation, ::Vec, ::Int)\nFerrite.shape_gradient_and_value\nFerrite.boundarydof_indices\nFerrite.dirichlet_boundarydof_indices","category":"page"},{"location":"devdocs/interpolations/#Ferrite.getdim-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.getdim","text":"Ferrite.getdim(::Interpolation)\n\nReturn the dimension of the reference element for a given interpolation.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.getrefshape-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.getrefshape","text":"Ferrite.getrefshape(::Interpolation)::AbstractRefShape\n\nReturn the reference element shape of the interpolation.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.getorder-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.getorder","text":"Ferrite.getorder(::Interpolation)\n\nReturn order of the interpolation.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.shape_gradient-Tuple{Interpolation, Vec, Int64}","page":"Interpolations","title":"Ferrite.shape_gradient","text":"shape_gradient(ip::Interpolation, Œæ::Vec, i::Int)\n\nEvaluate the gradient of the ith shape function of the interpolation ip in reference coordinate Œæ.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.shape_gradient_and_value","page":"Interpolations","title":"Ferrite.shape_gradient_and_value","text":"shape_gradient_and_value(ip::Interpolation, Œæ::Vec, i::Int)\n\nOptimized version combining the evaluation Ferrite.shape_value(::Interpolation) and Ferrite.shape_gradient(::Interpolation).\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#Ferrite.boundarydof_indices","page":"Interpolations","title":"Ferrite.boundarydof_indices","text":"boundarydof_indices(::Type{<:BoundaryIndex})\n\nHelper function to generically dispatch on the correct dof sets of a boundary entity.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#Ferrite.dirichlet_boundarydof_indices","page":"Interpolations","title":"Ferrite.dirichlet_boundarydof_indices","text":"dirichlet_boundarydof_indices(::Type{<:BoundaryIndex})\n\nHelper function to generically dispatch on the correct dof sets of a boundary entity. Used internally in ConstraintHandler and defaults to boundarydof_indices(ip::Interpolation) for continuous interpolation.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#Required-methods-to-implement-for-all-subtypes-of-Interpolation-to-define-a-new-finite-element","page":"Interpolations","title":"Required methods to implement for all subtypes of Interpolation to define a new finite element","text":"","category":"section"},{"location":"devdocs/interpolations/","page":"Interpolations","title":"Interpolations","text":"Depending on the dimension of the reference element the following functions have to be implemented","category":"page"},{"location":"devdocs/interpolations/","page":"Interpolations","title":"Interpolations","text":"Ferrite.shape_value(::Interpolation, ::Vec, ::Int)\nFerrite.vertexdof_indices(::Interpolation)\nFerrite.dirichlet_vertexdof_indices(::Interpolation)\nFerrite.facedof_indices(::Interpolation)\nFerrite.dirichlet_facedof_indices(::Interpolation)\nFerrite.facedof_interior_indices(::Interpolation)\nFerrite.edgedof_indices(::Interpolation)\nFerrite.dirichlet_edgedof_indices(::Interpolation)\nFerrite.edgedof_interior_indices(::Interpolation)\nFerrite.celldof_interior_indices(::Interpolation)\nFerrite.getnbasefunctions(::Interpolation)\nFerrite.reference_coordinates(::Interpolation)\nFerrite.face_to_element_transformation\nFerrite.is_discontinuous(::Interpolation)\nFerrite.adjust_dofs_during_distribution(::Interpolation)","category":"page"},{"location":"devdocs/interpolations/#Ferrite.shape_value-Tuple{Interpolation, Vec, Int64}","page":"Interpolations","title":"Ferrite.shape_value","text":"shape_value(ip::Interpolation, Œæ::Vec, i::Int)\n\nEvaluate the value of the ith shape function of the interpolation ip at a point Œæ on the reference element. The index i must match the index in vertices(::Interpolation), faces(::Interpolation) and edges(::Interpolation).\n\nFor nodal interpolations the indices also must match the indices of reference_coordinates(::Interpolation).\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.vertexdof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.vertexdof_indices","text":"vertexdof_indices(ip::Interpolation)\n\nA tuple containing tuples of local dof indices for the respective vertex in local enumeration on a cell defined by vertices(::Cell). The vertex enumeration must match the vertex enumeration of the corresponding geometrical cell.\n\nnote: Note\nThe dofs appearing in the tuple must be continuous and increasing! The first dof must be the 1, as vertex dofs are enumerated first.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.dirichlet_vertexdof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.dirichlet_vertexdof_indices","text":"dirichlet_vertexdof_indices(ip::Interpolation)\n\nA tuple containing tuples of local dof indices for the respective vertex in local enumeration on a cell defined by vertices(::Cell). The vertex enumeration must match the vertex enumeration of the corresponding geometrical cell. Used internally in ConstraintHandler and defaults to vertexdof_indices(ip::Interpolation) for continuous interpolation.\n\nnote: Note\nThe dofs appearing in the tuple must be continuous and increasing! The first dof must be the 1, as vertex dofs are enumerated first.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.facedof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.facedof_indices","text":"facedof_indices(ip::Interpolation)\n\nA tuple containing tuples of all local dof indices for the respective face in local enumeration on a cell defined by faces(::Cell). The face enumeration must match the face enumeration of the corresponding geometrical cell.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.dirichlet_facedof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.dirichlet_facedof_indices","text":"dirichlet_facedof_indices(ip::Interpolation)\n\nA tuple containing tuples of all local dof indices for the respective face in local enumeration on a cell defined by faces(::Cell). The face enumeration must match the face enumeration of the corresponding geometrical cell. Used internally in ConstraintHandler and defaults to facedof_indices(ip::Interpolation) for continuous interpolation.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.facedof_interior_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.facedof_interior_indices","text":"facedof_interior_indices(ip::Interpolation)\n\nA tuple containing tuples of the local dof indices on the interior of the respective face in local enumeration on a cell defined by faces(::Cell). The face enumeration must match the face enumeration of the corresponding geometrical cell. Note that the vertex and edge dofs are included here.\n\nnote: Note\nThe dofs appearing in the tuple must be continuous and increasing! The first dof must be the computed via \"last edge interior dof index + 1\", if face dofs exist.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.edgedof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.edgedof_indices","text":"edgedof_indices(ip::Interpolation)\n\nA tuple containing tuples of local dof indices for the respective edge in local enumeration on a cell defined by edges(::Cell). The edge enumeration must match the edge enumeration of the corresponding geometrical cell.\n\nThe dofs are guaranteed to be aligned with the local ordering of the entities on the oriented edge. Here the first entries are the vertex dofs, followed by the edge interior dofs.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.dirichlet_edgedof_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.dirichlet_edgedof_indices","text":"dirichlet_edgedof_indices(ip::Interpolation)\n\nA tuple containing tuples of local dof indices for the respective edge in local enumeration on a cell defined by edges(::Cell). The edge enumeration must match the edge enumeration of the corresponding geometrical cell. Used internally in ConstraintHandler and defaults to edgedof_indices(ip::Interpolation) for continuous interpolation.\n\nThe dofs are guaranteed to be aligned with the local ordering of the entities on the oriented edge. Here the first entries are the vertex dofs, followed by the edge interior dofs.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.edgedof_interior_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.edgedof_interior_indices","text":"edgedof_interior_indices(ip::Interpolation)\n\nA tuple containing tuples of the local dof indices on the interior of the respective edge in local enumeration on a cell defined by edges(::Cell). The edge enumeration must match the edge enumeration of the corresponding geometrical cell. Note that the vertex dofs are included here.\n\nnote: Note\nThe dofs appearing in the tuple must be continuous and increasing! The first dof must be computed via \"last vertex dof index + 1\", if edge dofs exist.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.celldof_interior_indices-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.celldof_interior_indices","text":"celldof_interior_indices(ip::Interpolation)\n\nTuple containing the dof indices associated with the interior of the cell.\n\nnote: Note\nThe dofs appearing in the tuple must be continuous and increasing! Celldofs are enumerated last.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.getnbasefunctions-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.getnbasefunctions","text":"Ferrite.getnbasefunctions(ip::Interpolation)\n\nReturn the number of base functions for the interpolation ip.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.reference_coordinates-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.reference_coordinates","text":"reference_coordinates(ip::Interpolation)\n\nReturns a vector of coordinates with length getnbasefunctions(::Interpolation) and indices corresponding to the indices of a dof in vertices, faces and edges.\n\nOnly required for nodal interpolations.\n\nTODO: Separate nodal and non-nodal interpolations.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.face_to_element_transformation","page":"Interpolations","title":"Ferrite.face_to_element_transformation","text":"face_to_element_transformation(point::Vec, ::Type{<:AbstractRefShape}, face::Int)\n\nTransform quadrature point from face's reference (N-1)D coordinates to ND coordinates on the cell's face.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#Ferrite.is_discontinuous-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.is_discontinuous","text":"is_discontinuous(::Interpolation)\nis_discontinuous(::Type{<:Interpolation})\n\nChecks whether the interpolation is discontinuous (i.e. DiscontinuousLagrange)\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/#Ferrite.adjust_dofs_during_distribution-Tuple{Interpolation}","page":"Interpolations","title":"Ferrite.adjust_dofs_during_distribution","text":"adjust_dofs_during_distribution(::Interpolation)\n\nThis function must return true if the dofs should be adjusted (i.e. permuted) during dof distribution. This is in contrast to i) adjusting the dofs during reinit! in the assembly loop, or ii) not adjusting at all (which is not needed for low order interpolations, generally).\n\n\n\n\n\n","category":"method"},{"location":"devdocs/interpolations/","page":"Interpolations","title":"Interpolations","text":"for all entities which exist on that reference element. The dof functions default to having no dofs defined on a specific entity. Hence, not overloading of the dof functions will result in an  element with zero dofs. Also, it should always be double checked that everything is consistent as  specified in the docstring of the corresponding function, as inconsistent implementations can lead to bugs which are really difficult to track down.","category":"page"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/fevalues/#FEValues","page":"FEValues","title":"FEValues","text":"","category":"section"},{"location":"reference/fevalues/#reference-cellvalues","page":"FEValues","title":"CellValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CellValues\nreinit!\ngetnquadpoints(::CellValues)\ngetdetJdV\n\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\n\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate","category":"page"},{"location":"reference/fevalues/#Ferrite.reinit!","page":"FEValues","title":"Ferrite.reinit!","text":"reinit!(cv::CellValues, x::Vector)\nreinit!(bv::FaceValues, x::Vector, face::Int)\n\nUpdate the CellValues/FaceValues object for a cell or face with coordinates x. The derivatives of the shape functions, and the new integration weights are computed.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_value","page":"FEValues","title":"Ferrite.shape_value","text":"shape_value(ip::Interpolation, Œæ::Vec, i::Int)\n\nEvaluate the value of the ith shape function of the interpolation ip at a point Œæ on the reference element. The index i must match the index in vertices(::Interpolation), faces(::Interpolation) and edges(::Interpolation).\n\nFor nodal interpolations the indices also must match the indices of reference_coordinates(::Interpolation).\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_gradient","page":"FEValues","title":"Ferrite.shape_gradient","text":"shape_gradient(ip::Interpolation, Œæ::Vec, i::Int)\n\nEvaluate the gradient of the ith shape function of the interpolation ip in reference coordinate Œæ.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_symmetric_gradient","page":"FEValues","title":"Ferrite.shape_symmetric_gradient","text":"shape_symmetric_gradient(fe_v::AbstractValues, q_point::Int, base_function::Int)\n\nReturn the symmetric gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_divergence","page":"FEValues","title":"Ferrite.shape_divergence","text":"shape_divergence(fe_v::AbstractValues, q_point::Int, base_function::Int)\n\nReturn the divergence of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_value","page":"FEValues","title":"Ferrite.function_value","text":"function_value(fe_v::AbstractValues, q_point::Int, u::AbstractVector)\n\nCompute the value of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe value of a scalar valued function is computed as u(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) u_i where u_i are the value of u in the nodes. For a vector valued function the value is calculated as mathbfu(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) mathbfu_i where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_gradient","page":"FEValues","title":"Ferrite.function_gradient","text":"function_gradient(fe_v::AbstractValues{dim}, q_point::Int, u::AbstractVector)\n\nCompute the gradient of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe gradient of a scalar function or a vector valued function with use of VectorValues is computed as mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx) u_i or mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla mathbfN_i (mathbfx) u_i respectively, where u_i are the nodal values of the function. For a vector valued function with use of ScalarValues the gradient is computed as mathbfnabla mathbfu(mathbfx) = sumlimits_i = 1^n mathbfu_i otimes mathbfnabla N_i (mathbfx) where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_symmetric_gradient","page":"FEValues","title":"Ferrite.function_symmetric_gradient","text":"function_symmetric_gradient(fe_v::AbstractValues, q_point::Int, u::AbstractVector)\n\nCompute the symmetric gradient of the function, see function_gradient. Return a SymmetricTensor.\n\nThe symmetric gradient of a scalar function is computed as left mathbfnabla  mathbfu(mathbfx_q) right^textsym =  sumlimits_i = 1^n  frac12 left mathbfnabla N_i (mathbfx_q) otimes mathbfu_i + mathbfu_i  otimes  mathbfnabla N_i (mathbfx_q) right where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_divergence","page":"FEValues","title":"Ferrite.function_divergence","text":"function_divergence(fe_v::AbstractValues, q_point::Int, u::AbstractVector)\n\nCompute the divergence of the vector valued function in a quadrature point.\n\nThe divergence of a vector valued functions in the quadrature point mathbfx_q) is computed as mathbfnabla cdot mathbfu(mathbfx_q) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx_q) cdot mathbfu_i where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.spatial_coordinate","page":"FEValues","title":"Ferrite.spatial_coordinate","text":"spatial_coordinate(fe_v::AbstractValues, q_point::Int, x::AbstractVector)\n\nCompute the spatial coordinate in a quadrature point. x contains the nodal coordinates of the cell.\n\nThe coordinate is computed, using the geometric interpolation, as mathbfx = sumlimits_i = 1^n M_i (mathbfx) mathbfhatx_i\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#reference-facevalues","page":"FEValues","title":"FaceValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"All of the methods for CellValues apply for FaceValues as well. In addition, there are some methods that are unique for FaecValues:","category":"page"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"FaceValues\ngetcurrentface\ngetnquadpoints(::FaceValues)","category":"page"},{"location":"reference/fevalues/#Ferrite.FaceValues","page":"FEValues","title":"Ferrite.FaceValues","text":"FaceValues([::Type{T}], quad_rule::FaceQuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA FaceValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. on the faces of finite elements.\n\nArguments:\n\nT: an optional argument to determine the type the internal data is stored as.\nquad_rule: an instance of a FaceQuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of an Interpolation which is used to interpolate the geometry. By default linear Lagrange interpolation is used.\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.getcurrentface","page":"FEValues","title":"Ferrite.getcurrentface","text":"getcurrentface(fv::FaceValues)\n\nReturn the current active face of the FaceValues object (from last reinit!).\n\n\n\n\n\ngetcurrentface(fv::OldFaceValues)\n\nReturn the current active face of the OldFaceValues object (from last reinit!).\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"start_assemble\nassemble!\nfinish_assemble","category":"page"},{"location":"reference/assembly/#Ferrite.start_assemble","page":"Assembly","title":"Ferrite.start_assemble","text":"start_assemble([N=0]) -> Assembler\n\nCreate an Assembler object which can be used to assemble element contributions to the global sparse matrix. Use assemble! for each element, and finish_assemble, to finalize the assembly and return the sparse matrix.\n\nNote that giving a sparse matrix as input can be more efficient. See below and  as described in the manual.\n\nnote: Note\nWhen the same matrix pattern is used multiple times (for e.g. multiple time steps or Newton iterations) it is more efficient to create the sparse matrix once and reuse the same pattern. See the manual section on assembly.\n\n\n\n\n\nstart_assemble(K::SparseMatrixCSC;            fillzero::Bool=true) -> AssemblerSparsityPattern\nstart_assemble(K::SparseMatrixCSC, f::Vector; fillzero::Bool=true) -> AssemblerSparsityPattern\n\nCreate a AssemblerSparsityPattern from the matrix K and optional vector f.\n\nstart_assemble(K::Symmetric{SparseMatrixCSC};                 fillzero::Bool=true) -> AssemblerSymmetricSparsityPattern\nstart_assemble(K::Symmetric{SparseMatrixCSC}, f::Vector=Td[]; fillzero::Bool=true) -> AssemblerSymmetricSparsityPattern\n\nCreate a AssemblerSymmetricSparsityPattern from the matrix K and optional vector f.\n\nAssemblerSparsityPattern and AssemblerSymmetricSparsityPattern allocate workspace necessary for efficient matrix assembly. To assemble the contribution from an element, use assemble!.\n\nThe keyword argument fillzero can be set to false if K and f should not be zeroed out, but instead keep their current values.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.assemble!","page":"Assembly","title":"Ferrite.assemble!","text":"assemble!(a::Assembler, dofs, Ke)\n\nAssembles the element matrix Ke into a.\n\n\n\n\n\nassemble!(a::Assembler, rowdofs, coldofs, Ke)\n\nAssembles the matrix Ke into a according to the dofs specified by rowdofs and coldofs.\n\n\n\n\n\nassemble!(g, dofs, ge)\n\nAssembles the element residual ge into the global residual vector g.\n\n\n\n\n\nassemble!(A::AbstractSparseAssembler, dofs::AbstractVector{Int}, Ke::AbstractMatrix)\nassemble!(A::AbstractSparseAssembler, dofs::AbstractVector{Int}, Ke::AbstractMatrix, fe::AbstractVector)\n\nAssemble the element stiffness matrix Ke (and optional force vector fe) into the global stiffness (and force) in A, given the element degrees of freedom dofs.\n\nThis is equivalent to K[dofs, dofs] += Ke and f[dofs] += fe, where K is the global stiffness matrix and f the global force/residual vector, but more efficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.finish_assemble","page":"Assembly","title":"Ferrite.finish_assemble","text":"finish_assemble(a::Assembler) -> K\n\nFinalizes an assembly. Returns a sparse matrix with the assembled values. Note that this step is not necessary for AbstractSparseAssemblers.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"create_sparsity_pattern\ncreate_symmetric_sparsity_pattern","category":"page"},{"location":"reference/assembly/#Ferrite.create_sparsity_pattern","page":"Assembly","title":"Ferrite.create_sparsity_pattern","text":"create_sparsity_pattern(dh::DofHandler; coupling, [topology::Union{Nothing, AbstractTopology}], [cross_coupling])\n\nCreate the sparsity pattern corresponding to the degree of freedom numbering in the DofHandler. Return a SparseMatrixCSC with stored values in the correct places.\n\nThe keyword arguments coupling and cross_coupling can be used to specify how fields (or components) in the dof handler couple to each other. coupling and cross_coupling should be square matrices of booleans with number of rows/columns equal to the total number of fields, or total number of components, in the DofHandler with true if fields are coupled and false if not. By default full coupling is assumed inside the element with no coupling between elements.\n\nIf topology and cross_coupling are passed, dof of fields with discontinuous interpolations are coupled between elements according to cross_coupling.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\ncreate_sparsity_pattern(dh::AbstractDofHandler, ch::ConstraintHandler; coupling, topology::Union{Nothing, AbstractTopology} = nothing)\n\nCreate a sparsity pattern accounting for affine constraints in ch. See the Affine Constraints section of the manual for further details.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.create_symmetric_sparsity_pattern","page":"Assembly","title":"Ferrite.create_symmetric_sparsity_pattern","text":"create_symmetric_sparsity_pattern(dh::DofHandler; coupling, topology::Union{Nothing, AbstractTopology}, cross_coupling)\n\nCreate the symmetric sparsity pattern corresponding to the degree of freedom numbering in the DofHandler by only considering the upper triangle of the matrix. Return a Symmetric{SparseMatrixCSC}.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\ncreate_symmetric_sparsity_pattern(dh::AbstractDofHandler, ch::ConstraintHandler; coupling, topology::Union{Nothing, AbstractTopology}, cross_coupling)\n\nCreate a symmetric sparsity pattern accounting for affine constraints in ch. See the Affine Constraints section of the manual for further details.\n\n\n\n\n\n","category":"function"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"topics/boundary_conditions/#Initial-and-Boundary-Conditions","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it Ferrite.","category":"page"},{"location":"topics/boundary_conditions/#Dirichlet-Boundary-Conditions","page":"Initial and Boundary Conditions","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"At a Dirichlet boundary the unknown field is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To handle Dirichlet boundary conditions in Ferrite we use the ConstraintHandler. A constraint handler is created from a DoF handler:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"ch = ConstraintHandler(dh)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"We can now create Dirichlet constraints and add them to the constraint handler. To create a Dirichlet constraint we need to specify a field name, a part of the boundary, and a function for computing the prescribed value. Example:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"dbc1 = Dirichlet(\n    :u,                       # Name of the field\n    getfaceset(grid, \"left\"), # Part of the boundary\n    x -> 1.0,                 # Function mapping coordinate to a prescribed value\n)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"The field name is given as a symbol, just like when the field was added to the dof handler, the part of the boundary where this constraint is active is given as a face set, and the function computing the prescribed value should be of the form f(x) or f(x, t) (coordinate x and time t) and return the prescribed value(s).","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Multiple sets\nTo apply a constraint on multiple face sets in the grid you can use union to join them, for exampleleft_right = union(getfaceset(grid, \"left\"), getfaceset(grid, \"right\"))creates a new face set containing all faces in the \"left\" and \"right\" face sets, which can be passed to the Dirichlet constructor.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"By default the constraint is added to all components of the given field. To add the constraint to selected components a fourth argument with the components should be passed to the constructor. Here is an example where a constraint is added to component 1 and 3 of a vector field :u:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"dbc2 = Dirichlet(\n    :u,                       # Name of the field\n    getfaceset(grid, \"left\"), # Part of the boundary\n    x -> [0.0, 0.0],          # Function mapping coordinate to prescribed values\n    [1, 3],                   # Components\n)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Note that the return value of the function must match with the components ‚Äì in the example above we prescribe components 1 and 3 to 0 so we return a vector of length 2.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Adding the constraints to the constraint handler is done with add!:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"add!(ch, dbc1)\nadd!(ch, dbc2)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Finally, just like for the dof handler, we need to use close! to finalize the constraint handler. Internally this will then compute the degrees-of-freedom that match the constraints we added.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"If one or more of the constraints depend on time, i.e. they are specified as f(x, t), the prescribed values can be recomputed in each new time step by calling update! with the proper time, e.g.:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"for t in 0.0:0.1:1.0\n    update!(ch, t) # Compute prescribed values for this t\n    # Solve for time t...\nend","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Examples\nMost examples make use of Dirichlet boundary conditions, for example Heat Equation.","category":"page"},{"location":"topics/boundary_conditions/#Neumann-Boundary-Conditions","page":"Initial and Boundary Conditions","title":"Neumann Boundary Conditions","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"At the Neumann part of the boundary we know something about the gradient of the solution. Two different methods for applying these are described below. For complete examples that use Neumann boundary conditions, please see","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"von-Mises-plasticity\nHyperelasticity","category":"page"},{"location":"topics/boundary_conditions/#Using-the-FaceIterator","page":"Initial and Boundary Conditions","title":"Using the FaceIterator","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"A Neumann boundary contribution can be added by iterating over the relevant faceset::Set{FaceIndex} by using the FaceIterator For a scalar field, this can be done as","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"grid = generate_grid(Quadrilateral, (3,3))\ndh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\nfv = FaceValues(QuadratureRule{RefQuadrilateral}(2), Lagrange{RefQuadrilateral, 1}())\nf = zeros(ndofs(dh))\nfe = zeros(ndofs_per_cell(dh))\nqn = 1.0    # Normal flux\nfor fc in FaceIterator(dh, getfaceset(grid, \"right\"))\n    reinit!(fv, fc)\n    fill!(fe, 0)\n    for q_point in 1:getnquadpoints(fv)\n        dŒì = getdetJdV(fv, q_point)\n        for i in 1:getnbasefunctions(fv)\n            Œ¥u = shape_value(fv, q_point, i)\n            fe[i] += Œ¥u * qn * dŒì\n        end\n    end\n    assemble!(f, celldofs(fc), fe)\nend","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Alternatively, it is possible to add the values directly to the global f (without going through the local fe vector and then using assemble!):","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"# ...\ndofs = celldofs(fc)\nfor i in 1:getnbasefunctions(fv)\n    f[dofs[i]] += Œ¥u * qn * dŒì\nend","category":"page"},{"location":"topics/boundary_conditions/#In-the-element-routine","page":"Initial and Boundary Conditions","title":"In the element routine","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Alternatively, the following code snippet can be included in the element routine, to evaluate the boundary integral:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"for face in 1:nfaces(cell)\n    if (cellid(cell), face) ‚àà getfaceset(grid, \"Neumann Boundary\")\n        reinit!(facevalues, cell, face)\n        for q_point in 1:getnquadpoints(facevalues)\n            dŒì = getdetJdV(facevalues, q_point)\n            for i in 1:getnbasefunctions(facevalues)\n                Œ¥u = shape_value(facevalues, q_point, i)\n                fe[i] += Œ¥u * qn * dŒì\n            end\n        end\n    end\nend","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"We start by looping over all the faces of the cell, next we check if this particular face is located on our faceset of interest called \"Neumann Boundary\". If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize facevalues for this face, using reinit!. When reinit!ing facevalues we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.","category":"page"},{"location":"topics/boundary_conditions/#Periodic-boundary-conditions","page":"Initial and Boundary Conditions","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Periodic boundary conditions ensure that the solution is periodic across two boundaries. To define the periodicity we first define the image boundary Gamma^+ and the mirror boundary Gamma^-. We also define a (unique) coordinate mapping between the image and the mirror: varphi Gamma^+ rightarrow Gamma^-. With the mapping we can, for every coordinate on the image, compute the corresponding coordinate on the mirror:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"boldsymbolx^- = varphi(boldsymbolx^+)quad boldsymbolx^- in Gamma^-\nboldsymbolx^+ in Gamma^+","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"We now want to ensure that the solution on the image Gamma^+ is mirrored on the mirror Gamma^-. This periodicity constraint can thus be described by","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"u(boldsymbolx^-) = u(boldsymbolx^+)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Sometimes this is written as","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"llbracket u rrbracket = 0","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"where llbracket bullet rrbracket = bullet(boldsymbolx^+) - bullet(boldsymbolx^-) is the \"jump operator\". Thus, this condition ensure that the jump, or difference, in the solution between the image and mirror boundary is the zero ‚Äì the solution becomes periodic. For a vector valued problem the periodicity constraint can in general be written as","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"boldsymbolu(boldsymbolx^-) = boldsymbolR cdot boldsymbolu(boldsymbolx^+)\nquad Leftrightarrow quad llbracket boldsymbolu rrbracket =\nboldsymbolR cdot boldsymbolu(boldsymbolx^+) - boldsymbolu(boldsymbolx^-) =\nboldsymbol0","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"where boldsymbolR is a rotation matrix. If the mapping between mirror and image is simply a translation (e.g. sides of a cube) this matrix will be the identity matrix.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"In Ferrite this type of periodic Dirichlet boundary conditions can be added to the ConstraintHandler by constructing an instance of PeriodicDirichlet. This is usually done it two steps. First we compute the mapping between mirror and image faces using collect_periodic_faces. Here we specify the mirror set and image sets (the sets are usually known or can be constructed easily ) and the mapping varphi. Second we construct the constraint using the PeriodicDirichlet constructor. Here we specify which components of the function that should be constrained, and the rotation matrix boldsymbolR (when needed). When adding the constraint to the ConstraintHandler the resulting dof-mapping is computed.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Here is a simple example where periodicity is enforced for components 1 and 2 of the field :u between the mirror boundary set \"left\" and the image boundary set \"right\". Note that no rotation matrix is needed here since the mirror and image are parallel, just shifted in the x-direction (as seen by the mapping œÜ):","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"# Create a constraint handler from the dof handler\nch = ConstraintHandler(dofhandler)\n\n# Compute the face mapping\nœÜ(x) = x - Vec{2}((1.0, 0.0))\nface_mapping = collect_periodic_faces(grid, \"left\", \"right\", œÜ)\n\n# Construct the periodic constraint for field :u\npdbc = PeriodicDirichlet(:u, face_mapping, [1, 2])\n\n# Add the constraint to the constraint handler\nadd!(ch, pdbc)\n\n# If no more constraints should be added we can close\nclose!(ch)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Note\nPeriodicDirichlet constraints are imposed in a strong sense, so note that this requires a periodic mesh such that it is possible to compute the face mapping between faces on the mirror and boundary.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Examples\nPeriodic boundary conditions are used in the following examples Computational homogenization, Stokes flow.","category":"page"},{"location":"topics/boundary_conditions/#Heterogeneous-\"periodic\"-constraint","page":"Initial and Boundary Conditions","title":"Heterogeneous \"periodic\" constraint","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"It is also possible to define constraints of the form","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"llbracket u rrbracket = llbracket f rrbracket\nquad Leftrightarrow quad\nu(boldsymbolx^+) - u(boldsymbolx^-) =\nf(boldsymbolx^+) - f(boldsymbolx^-)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"where f is a prescribed function. Although the constraint in this case is not technically periodic, PeriodicDirichlet can be used for this too. This is done by passing a function to PeriodicDirichlet, similar to Dirichlet, which, given the coordinate boldsymbolx and time t, computes the prescribed values of f on the boundary.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Here is an example of how to implement this type of boundary condition, for a known function f:","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"pdbc = PeriodicDirichlet(\n    :u,\n    face_mapping,\n    (x, t) -> f(x),\n    [1, 2],\n)","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Note\nOne application for this type of boundary conditions is multiscale modeling and computational homogenization when solving the finite element problem for the subscale. In this case the unknown u is split into a macroscopic part u^mathrmM and a microscopic/fluctuation part u^mu, i.e. u = u^mathrmM + u^mu. Periodicity is then usually enforced for the fluctuation part, i.e. llbracket u^mu rrbracket = 0. The equivalent constraint for u then becomes llbracket u rrbracket = llbracket u^mathrmM rrbracket.As an example, consider first order homogenization where the macroscopic part is constructed as u^mathrmM = baru + boldsymbolnabla baru cdot boldsymbolx - barboldsymbolx for known baru and boldsymbolnabla baru. This could be implemented aspdbc = PeriodicDirichlet(\n    :u,\n    face_mapping,\n    (x, t) -> uÃÑ + ‚àáuÃÑ  ‚ãÖ (x - xÃÑ)\n)","category":"page"},{"location":"topics/boundary_conditions/#Initial-Conditions","page":"Initial and Boundary Conditions","title":"Initial Conditions","text":"","category":"section"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"When solving time-dependent problems, initial conditions, different from zero, may be required.  For finite element formulations of ODE-type,  i.e. boldsymbolu(t) = boldsymbolf(boldsymbolu(t)t),  where boldsymbolu(t) are the degrees of freedom, initial conditions can be specified by the apply_analytical! function. For example, specify the initial pressure as a function of the y-coordinate","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"œÅ = 1000; g = 9.81    # density [kg/m¬≥] and gravity [N/kg]\ngrid = generate_grid(Quadrilateral, (10,10))\ndh = DofHandler(grid); add!(dh, :u, 2); add!(dh, :p, 1); close!(dh)\nu = zeros(ndofs(dh))\napply_analytical!(u, dh, :p, x -> œÅ * g * x[2])","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"See also Transient heat equation for one example.","category":"page"},{"location":"topics/boundary_conditions/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"note: Consistency\napply_analytical! does not enforce consistency of the applied solution with the system of equations. Some problems, like for example differential-algebraic systems of equations (DAEs) need extra care during initialization. We refer to the paper \"Consistent Initial Condition Calculation for Differential-Algebraic Systems\" by Brown et al. for more details on this matter.","category":"page"},{"location":"devdocs/performance/#devdocs-performance","page":"Performance Analysis","title":"Performance Analysis","text":"","category":"section"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"In the benchmark folder we provide basic infrastructure to analyze the performance of Ferrite to help tracking down performance regression issues. Two basic tools can be directly executed via make: A basic benchmark for the current branch and a comparison between two commits. To execute the benchmark on the current branch only open a shell in the benchmark folder and call","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"make benchmark","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"whereas for the comparison of two commits simply call","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"make compare target=<target-commit> baseline=<baseline-commit>","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"If you have a custom julia executable that is not accessible via the julia command, then you can pass the executable via","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"JULIA_CMD=<path-to-julia-executable> make compare target=<target-commit> baseline=<baseline-commit>","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"note: Note\nFor the performance comparison between two commits you must not have any uncommitted or untracked files in your Ferrite.jl folder! Otherwise the PkgBenchmark.jl will fail to setup the comparison.","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"For more fine grained control you can run subsets of the benchmarks via by appending -<subset> to compare or benchmark, e.g.","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"make benchmark-mesh","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"to benchmark only the mesh functionality. The following subsets are currently available:","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"assembly\nboundary-conditions\ndofs\nmesh","category":"page"},{"location":"devdocs/performance/","page":"Performance Analysis","title":"Performance Analysis","text":"note: Note\nIt is recommended to run all benchmarks before running subsets to get the correct tuning parameters for each benchmark.","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"using Ferrite\ngrid = generate_grid(Triangle, (2, 2))\ndh = DofHandler(grid); add!(dh, :u, Lagrange{2,RefTetrahedron,1}()); close!(dh)\nu = rand(ndofs(dh)); œÉ = rand(getncells(grid))","category":"page"},{"location":"topics/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"topics/export/","page":"Export","title":"Export","text":"When the problem is solved, and the solution vector u is known we typically want to visualize it. The simplest way to do this is to write the solution to a VTK-file, which can be viewed in e.g. Paraview. To write VTK-files, Ferrite uses, and extends, functions from the WriteVTK.jl package to simplify the exporting.","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"First we need to create a file, based on the grid. This is done with the vtk_grid function:","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", grid)\n# hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"Next we have to add data to the file. We may add different kinds of data; point data using vtk_point_data or cell data using vtk_cell_data. Point data is data for each nodal coordinate in the grid, for example our solution vector. Point data can be either scalars or vectors. Cell data is ‚Äì as the name suggests ‚Äì data for each cell. This can be for example the stress. As an example, lets add a solution vector u as point data, and a vector with stress for each cell, œÉ, as cell data:","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk_point_data(vtk, u, \"my-point-data\")\nvtk_cell_data(vtk,  œÉ, \"my-cell-data\")\n# hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"Finally, we need to save the file to disk, using vtk_save","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"Alternatively, all of the above can be done using a do block:","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", grid) do vtk\n    vtk_point_data(vtk, u, \"my-point-data\")\n    vtk_cell_data(vtk, œÉ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"For other functionality, and more information refer to the WriteVTK.jl README. In particular, for exporting the solution at multiple time steps, the section on PVD files is useful.","category":"page"},{"location":"topics/export/#Exporting-with-DofHandler","page":"Export","title":"Exporting with DofHandler","text":"","category":"section"},{"location":"topics/export/","page":"Export","title":"Export","text":"There is an even more convenient way to export a solution vector u ‚Äì using the DofHandler. The DofHandler already contains all of the information needed, such as the names of our fields and if they are scalar or vector fields. But most importantly the DofHandler knows about the numbering and distribution of degrees of freedom, and thus knows how to \"distribute\" the solution vector on the grid. For example, lets say we have a DofHandler dh and a solution vector u:","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", dh)\nvtk_point_data(vtk, dh, u)\nvtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"or with a do-block:","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\n    vtk_cell_data(vtk, œÉ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"When vtk_point_data is used with a DofHandler all of the fields will be written to the VTK file, and the names will be determined by the fieldname symbol that was used when the field was added to the DofHandler.","category":"page"},{"location":"topics/export/#Exporting-Boundary-Conditions","page":"Export","title":"Exporting Boundary Conditions","text":"","category":"section"},{"location":"topics/export/","page":"Export","title":"Export","text":"There is also a vtk_point_data which accepts a ConstraintHandler. This method is useful to verify that the boundary conditions are applied where they are supposed to. For a ConstraintHandler ch we can export the boundary conditions as","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"vtk_grid(\"boundary-conditions\", grid) do vtk\n    vtk_point_data(vtk, ch)\nend","category":"page"},{"location":"topics/export/","page":"Export","title":"Export","text":"This will export zero-valued fields with ones on the parts where the boundary conditions are active.","category":"page"},{"location":"topics/fe_intro/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Here we will present a very brief introduction to partial differential equations (PDEs) and to the finite element method (FEM). Perhaps the simplest PDE of all is the (steady-state, linear) heat equation, also known as the Poisson equation. We will use this equation as a demonstrative example of the method, and demonstrate how we go from the strong form of the equation, to the weak form, and then finally to the discrete FE problem.","category":"page"},{"location":"topics/fe_intro/#Strong-form","page":"Introduction to FEM","title":"Strong form","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The strong form of the heat equation may be written as:","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"- nabla cdot mathbfq(u) = f quad forall  mathbfx in Omega","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where u is the unknown temperature field, mathbfq is the heat flux, f is an internal heat source, and Omega is the domain on which the equation is defined. To complete the problem we need to specify what happens at the domain boundary Gamma. This set of specifications is called boundary conditions. There are different types of boundary conditions, where the most common ones are Dirichlet ‚Äì which means that the solution u is known at some part of the boundary, and Neumann ‚Äì which means that the gradient of the solution, nabla u is known. Formally we write for our example","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u = u^mathrmp quad forall  mathbfx in Gamma_mathrmD\nmathbfq cdot mathbfn = q^mathrmp quad forall  mathbfx in Gamma_mathrmN","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"i.e. the temperature is prescribed to a known function u^mathrmp at the Dirichlet part of the boundary, Gamma_mathrmD, and the heat flux is prescribed to q^mathrmp at the Neumann part of the boundary, Gamma_mathrmN, where mathbfn describes the outward pointing normal vector at the boundary.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We also need a constitutive equation which links the temperature field, u, to the heat flux, mathbfq. The simplest case is to use Fourier's law","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"mathbfq(u) = -k nabla u","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where k is the conductivity of the material. In general the conductivity can vary throughout the domain as a function of the coordinate, i.e. k = k(mathbfx), but for simplicity we will consider only constant conductivity k.","category":"page"},{"location":"topics/fe_intro/#Weak-form","page":"Introduction to FEM","title":"Weak form","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the equation above is usually calculated from the corresponding weak form. By multiplying the equation with an arbitrary test function delta u, integrating over the domain and using partial integration we obtain the weak form. Now our problem can be stated as:","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Find u in mathbbU s.t.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"int_Omega nabla delta u cdot (k nabla u)  mathrmdOmega =\nint_Gamma_mathrmN delta u  q^mathrmp  mathrmdGamma +\nint_Omega delta u  b  mathrmdOmega quad forall  delta u in mathbbT","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where mathbbU mathbbT are suitable function spaces with sufficiently regular functions. Under very general assumptions it can be shown that the solution to the weak form is identical to the solution to the strong form.","category":"page"},{"location":"topics/fe_intro/#Finite-Element-approximation","page":"Introduction to FEM","title":"Finite Element approximation","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Using the finite element method to solve partial differential equations is usually preceded with the construction of a discretization of the domain Omega into a finite set of elements or cells. We call this geometric discretization grid (or mesh) and denote it with Omega_h. In this example the corners of the triangles are called nodes.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Next we introduce the finite element approximation u_mathrmh approx u as a sum of N nodal shape functions, where we denote each of these function by phi_i and the corresponding nodal values hatu_i. Note that shape functions are sometimes referred to as base functions or trial functions, and instead of phi_i they are sometimes denoted N_i. In this example we choose to approximate the test function in the same way. This approach is known as the Galerkin finite element method. Formally we write the evaluation of our approximations at a specific point mathbfx in our domain Omega as:","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_mathrmh(mathbfx) = sum_i=1^mathrmN phi_i(mathbfx)  hatu_iqquad\ndelta u_mathrmh(mathbfx) = sum_i=1^mathrmN phi_i(mathbfx)  delta hatu_i  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since test and trial functions are usually chosen in such a way, that they build the basis of some function space (basis as in basis of a vector space), sometimes are they are also called basis functions. In the following the argument mathbfx is dropped to keep the notation compact. We may now insert these approximations in the weak form, which results in","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"sum_i^N delta hatu_i left(sum_j^N int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j)  mathrmdOmega  hatu_j right) =\nsum_i^N delta hatu_i left( int_Gamma_mathrmN phi_i  q^mathrmp  mathrmdGamma +\nint_Omega_mathrmh phi_i  f  mathrmdOmega right)  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since this equation must hold for arbitrary delta u_mathrmh, the equation must especially hold for the specific choice that only one of the nodal values delta hatu_i is fixed to 1 while an all other coefficients are fixed to 0. Repeating this argument for all i from 1 to N we obtain N linear equations. This way the discrete problem can be written as a system of linear equations","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineunderlineK underlinehatu = underlinehatf  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where we call underlineunderlineK the (tangent) stiffness matrix, underlinehatu the solution vector with the nodal values and underlinehatf the force vector. The specific naming is for historical reasons, because the finite element method has its origins in mechanics. The elements of underlineunderlineK and underlinehatf are given by","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(underlineunderlineK)_ij =\n    int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j) mathrmdOmega   \n\n(underlinehatf)_i =\n    int_Gamma_mathrmN phi_i  q^mathrmp  mathrmdGamma + int_Omega_mathrmh phi_i  f  mathrmdOmega  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Finally we also need to take care of the Dirichlet boundary conditions. These are enforced by setting the corresponding hatu_i to the prescribed values and eliminating the associated equations from the system. Now, solving this equation system yields the nodal values and thus an approximation to the true solution.","category":"page"},{"location":"topics/fe_intro/#Notes-on-the-implementation","page":"Introduction to FEM","title":"Notes on the implementation","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In practice, the shape functions phi_i are only non-zero on parts of the domain Omega_mathrmh. Thus, the integrals are evaluated on sub-domains, called elements or cells.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Each cell gives a contribution to the global stiffness matrix and force vector. The process of constructing the system of equations is also called assembly. For clarification, let us rewrite the formula for the stiffness matrix entries as follows:","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(underlineunderlineK)_ij\n    = int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j) mathrmdOmega\n    = sum_E in Omega_mathrmh int_E nabla phi_i cdot (k nabla phi_j) mathrmdOmega  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This formulation underlines the element-centric perspective of finite element methods and reflects how it is usually implemented in software.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Computing the element integrals by hand can become a tedious task. To avoid this issue we approximate the element integrals with a technique called numerical integration. Skipping any of the mathematical details, the basic idea is to evaluate the function under the integral at specific points and weighting the evaluations accordingly, such that their sum approximates the volume properly. A very nice feature of these techniques is, that under quite general circumstances the formula is not just an approximation, but the exact evaluation of the integral. To avoid the recomputation of the just mentioned evaluation positions of the integral for each individual element, we perform a coordinate transformation onto a so-called reference element. Formally we write","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"    int_E nabla phi_i cdot (k nabla phi_j) mathrmdOmega\n    approx sum_q nabla phi_i(textbfx_q) cdot (k(textbfx_q) nabla phi_j(textbfx_q))  w_q  textrmdet(J(textbfx_q))  ","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where J is the Jacobian of the coordinate transformation function. The computation of the transformation, weights, positions and of the Jacobi determinant is handled by Ferrite. On an intuitive level, and to explain the notation used in the implementation, we think of","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"    mathrmdOmega approx  w  textrmdet(J)","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"being the chosen approximation when changing from the integral to the finite summation.","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"For an example of the implementation to solve a heat problem with Ferrite check out this thoroughly commented example.","category":"page"},{"location":"topics/fe_intro/#More-details","page":"Introduction to FEM","title":"More details","text":"","category":"section"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We finally want to note that this quick introduction barely scratches the surface of the finite element method. Also, we presented some things in a simplified way for the sake of keeping this article short and concise. There is a large corpus of literature and online tutorials containing more details about the finite element method. To give a few recommendations there is:","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Hans Petter Langtangen's Script\nWolfgang Bangerth's Lecture Series\nIntroduction to the Finite Element Method by Niels Ottosen and Hans Petersson\nThe Finite Element Method for Elliptic Problems by Philippe Ciarlet\nFinite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess\nAn Analysis of the Finite Element Method by Gilbert Strang and George Fix\nFinite Element Procedures by Klaus-J√ºrgen Bathe\nThe Finite Element Method: Its Basis and Fundamentals by Olgierd Cecil Zienkiewicz, Robert Taylor and J.Z. Zhu\nHigher-Order Finite Element Methods by Pavel ≈†ol√≠n, Karel Segeth and Ivo Dole≈æel","category":"page"},{"location":"topics/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This list is neither meant to be exhaustive, nor does the absence of a work mean that it is in any way bad or not recommendable. The ordering of the articles also has no particular meaning.","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"On this page you find an overview of Ferrite tutorials. The tutorials explain and show how Ferrite can be used to solve a wide range of problems. See also the Code gallery for more examples.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The tutorials all follow roughly the same structure:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Introduction introduces the problem to be solved and discusses the learning outcomes of the tutorial.\nCommented program is the code for solving the problem with explanations and comments.\nPlain program is the raw source code of the program.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"When studying the tutorials it is a good idea to obtain a local copy of the code and run it on your own machine as you read along. Some of the tutorials also include suggestions for tweaks to the program that you can try out on your own.","category":"page"},{"location":"tutorials/#Tutorial-index","page":"Tutorials","title":"Tutorial index","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The tutorials are listed in roughly increasing order of complexity. However, since they focus on different aspects, and solve different problems, it is suggested to have a look at the brief descriptions below to get an idea about what you will learn from each tutorial.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"If you are new to Ferrite then Tutorial 1 - Tutorial 6 is the best place to start. These tutorials introduces and teaches most of the basic finite element techniques (e.g. linear and non-linear problems, scalar- and vector-valued problems, Dirichlet and Neumann boundary conditions, mixed finite elements, time integration, direct and iterative linear solvers, etc). In particular the very first tutorial is essential in order to be able to follow any of the other tutorials. The remaining tutorials discuss more advanced topics.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-1:-Heat-equation](heat_equation.md)","page":"Tutorials","title":"Tutorial 1: Heat equation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial guides you through the process of solving the linear stationary heat equation (i.e. Poisson's equation) on a unit square with homogeneous Dirichlet boundary conditions. This tutorial introduces and teaches many important parts of Ferrite: problem setup, degree of freedom management, assembly procedure, boundary conditions, solving the linear system, visualization of the result). Understanding this tutorial is essential to follow more complex tutorials.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: scalar-valued solution, Dirichlet boundary conditions.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-2:-Linear-elasticity](linear_elasticity.md)","page":"Tutorials","title":"Tutorial 2: Linear elasticity","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TBW.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: vector-valued solution, Dirichlet and Neumann boundary conditions.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-3:-Incompressible-elasticity](incompressible_elasticity.md)","page":"Tutorials","title":"Tutorial 3: Incompressible elasticity","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial focuses on a mixed formulation of linear elasticity, with (vector) displacement and (scalar) pressure as the two unknowns, suitable for incompressibility. Thus, this tutorial guides you through the process of solving a problem with two unknowns from two coupled weak forms. The problem that is studied is Cook's membrane in the incompressible limit.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: mixed finite elements, Dirichlet and Neumann boundary conditions.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-4:-Hyperelasticity](hyperelasticity.md)","page":"Tutorials","title":"Tutorial 4: Hyperelasticity","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial you will learn how to solve a non-linear finite element problem. In particular, a hyperelastic material model, in a finite strain setting, is used to solve the rotation of a cube. Automatic differentiatio (AD) is used for the consitutive relations. Newton's method is used for the non-linear iteration, and a conjugate gradient (CG) solver is used for the linear solution of the increment.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: non-linear finite element, finite strain, automatic differentiation (AD), Newton's method, conjugate gradient (CG).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-5:-von-Mises-Plasticity](plasticity.md)","page":"Tutorials","title":"Tutorial 5: von Mises Plasticity","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial revisits the cantilever beam problem from Tutorial 2: Linear elasticity, but instead of linear elasticity a plasticity model is used for the constitutive relation. You will learn how to solve a problem which require the solution of a local material problem, and the storage of material state, in each quadrature point. Newton's method is used both locally in the material routine, and globally on the finite element level.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: non-linear finite element, plasticity, material modeling, state variables, Newton‚Äôs method.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-6:-Transient-heat-equation](@ref-tutorial-transient-heat-equation)","page":"Tutorials","title":"Tutorial 6: Transient heat equation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial the transient heat equation is solved on the unit square. The problem to be solved is thus similar to the one solved in the first tutorial, Heat equation, but with time-varying boundary conditions. In particular you will learn how to solve a time dependent problem with an implicit Euler scheme for the time integration.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: time dependent finite elements, implicit Euler time integration.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-7:-Computational-homogenization](computational_homogenization.md)","page":"Tutorials","title":"Tutorial 7: Computational homogenization","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial guides you through computational homogenization of an representative volume element (RVE) consisting of a soft matrix material with stiff inclusions. The computational mesh is read from an external mesh file generated with Gmsh. Dirichlet and periodic boundary conditions are used.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: Gmsh mesh reading, Dirichlet and periodic boundary conditions","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-8:-Stokes-flow](stokes-flow.md)","page":"Tutorials","title":"Tutorial 8: Stokes flow","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial Stokes flow with (vector) velocity and (scalar) pressure is solved on on a quarter circle. Rotationally periodic boundary conditions is used for the inlet/outlet coupling. To obtain a unique solution, a mean value constraint is applied on the pressure using an affine constraint. The computational mesh is generated directly using the Gmsh API.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: periodic boundary conditions, mean value constraint, mesh generation with Gmsh.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-9:-Incompressible-Navier-Stokes-equations](ns_vs_diffeq.md)","page":"Tutorials","title":"Tutorial 9: Incompressible Navier-Stokes equations","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial the incompressible Navier-Stokes equations are solved. The domain is discretized in space with Ferrite as usual, and then forumalated in a way to be compatible with the OrdinaryDiffEq.jl package, which is used for the time-integration.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: non-linear time dependent problem","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#[Tutorial-10:-Linear-shell](@ref-tutorial-linear-shell)","page":"Tutorials","title":"Tutorial 10: Linear shell","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial a linear shell element formulation is set up as a two-dimensional domain embedded in three-dimensional space. This will teach, and perhaps inspire, you on how Ferrite can be used for non-standard things and how to add \"hacks\" that build on top of Ferrite.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Keywords: embedding, automatic differentiation","category":"page"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/export/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/#Project-to-nodes","page":"Postprocessing","title":"Project to nodes","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"L2Projector\nproject","category":"page"},{"location":"reference/export/#Ferrite.L2Projector","page":"Postprocessing","title":"Ferrite.L2Projector","text":"L2Projector(func_ip::Interpolation, grid::AbstractGrid; kwargs...)\n\nCreate an L2Projector used for projecting quadrature data. func_ip is the function interpolation used for the projection and grid the grid over which the projection is applied.\n\nKeyword arguments:\n\nqr_lhs: quadrature for the left hand side. Defaults to a quadrature which exactly integrates a mass matrix with func_ip as the interpolation.\nset: element set over which the projection applies. Defaults to all elements in the grid.\ngeom_ip: geometric interpolation. Defaults to the default interpolation for the grid.\n\nThe L2Projector acts as the integrated left hand side of the projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project.\n\nUse project to integrate the right hand side and solve for the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.project","page":"Postprocessing","title":"Ferrite.project","text":"project(proj::L2Projector, vals, qr_rhs::QuadratureRule)\n\nMakes a L2 projection of data vals to the nodes of the grid using the projector proj (see L2Projector).\n\nproject integrates the right hand side, and solves the projection u from the following projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project, i.e. vals.\n\nThe data vals should be a vector, with length corresponding to number of elements, of vectors, with length corresponding to number of quadrature points per element, matching the number of points in qr_rhs. Alternatively, vals can be a matrix, with number of columns corresponding to number of elements, and number of rows corresponding to number of points in qr_rhs. Example (scalar) input data:\n\nvals = [\n    [0.44, 0.98, 0.32], # data for quadrature point 1, 2, 3 of element 1\n    [0.29, 0.48, 0.55], # data for quadrature point 1, 2, 3 of element 2\n    # ...\n]\n\nor equivalent in matrix form:\n\nvals = [\n    0.44 0.29 # ...\n    0.98 0.48 # ...\n    0.32 0.55 # ...\n]\n\nSupported data types to project are Numbers and AbstractTensors.\n\nThe order of the returned data correspond to the order of the L2Projectors internal DofHandler. To export the result, use vtk_point_data(vtk, proj, projected_data).\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Postprocessing-2","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"PointEvalHandler\nevaluate_at_points\nFerrite.PointValues\nPointIterator\nPointLocation","category":"page"},{"location":"reference/export/#Ferrite.PointEvalHandler","page":"Postprocessing","title":"Ferrite.PointEvalHandler","text":"PointEvalHandler(grid::Grid, points::AbstractVector{Vec{dim,T}}; kwargs...) where {dim, T}\n\nThe PointEvalHandler can be used for function evaluation in arbitrary points in the domain ‚Äì not just in quadrature points or nodes.\n\nThe PointEvalHandler takes the following keyword arguments:\n\nsearch_nneighbors: How many nodes should be found in the nearest neighbor search for each point. Usually there is no need to change this setting. Default value: 3.\nwarn: Show a warning if a point is not found. Default value: true.\n\nThe constructor takes a grid and a vector of coordinates for the points. The PointEvalHandler computes i) the corresponding cell, and ii) the (local) coordinate within the cell, for each point. The fields of the PointEvalHandler are:\n\ncells::Vector{Union{Int,Nothing}}: vector with cell IDs for the points, with nothing for points that could not be found.\nlocal_coords::Vector{Union{Vec,Nothing}}: vector with the local coordinates (i.e. coordinates in the reference configuration) for the points, with nothing for points that could not be found.\n\nThere are two ways to use the PointEvalHandler to evaluate functions:\n\nevaluate_at_points: can be used when the function is described by i) a dh::DofHandler + uh::Vector (for example the FE-solution), or ii) a p::L2Projector + ph::Vector (for projected data).\nIteration with PointIterator + PointValues: can be used for more flexible evaluation in the points, for example to compute gradients.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.evaluate_at_points","page":"Postprocessing","title":"Ferrite.evaluate_at_points","text":"evaluate_at_points(ph::PointEvalHandler, dh::AbstractDofHandler, dof_values::Vector{T}, [fieldname::Symbol]) where T\nevaluate_at_points(ph::PointEvalHandler, proj::L2Projector, dof_values::Vector{T}) where T\n\nReturn a Vector{T} (for a 1-dimensional field) or a Vector{Vec{fielddim, T}} (for a vector field) with the field values of field fieldname in the points of the PointEvalHandler. The fieldname can be omitted if only one field is stored in dh. The field values are computed based on the dof_values and interpolated to the local coordinates by the function interpolation of the corresponding field stored in the AbstractDofHandler or the L2Projector.\n\nPoints that could not be found in the domain when constructing the PointEvalHandler will have NaNs for the corresponding entries in the output vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Ferrite.PointValues","page":"Postprocessing","title":"Ferrite.PointValues","text":"PointValues(cv::CellValues)\nPointValues(ip_f::Interpolation, ip_g::Interpolation=ip_f)\n\nSimilar to CellValues but with a single updateable \"quadrature point\". PointValues are used for evaluation of functions/gradients in arbitrary points of the domain together with a PointEvalHandler.\n\nPointValues can be created from CellValues, or from the interpolations directly.\n\nPointValues are reinitialized like other CellValues, but since the local reference coordinate of the \"quadrature point\" changes this needs to be passed to reinit!, in addition to the element coordinates: reinit!(pv, coords, local_coord). Alternatively, it can be reinitialized with a PointLocation when iterating a PointEvalHandler with a PointIterator.\n\nFor function/gradient evaluation, PointValues are used in the same way as CellValues, i.e. by using function_value, function_gradient, etc, with the exception that there is no need to specify the quadrature point index (since PointValues only have 1, this is the default).\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.PointIterator","page":"Postprocessing","title":"Ferrite.PointIterator","text":"PointIterator(ph::PointEvalHandler)\n\nCreate an iterator over the points in the PointEvalHandler. The elements of the iterator are either a PointLocation, if the corresponding point could be found in the grid, or nothing, if the point was not found.\n\nA PointLocation can be used to query the cell ID with the cellid function, and can be used to reinitialize PointValues with reinit!.\n\nExamples\n\nph = PointEvalHandler(grid, points)\n\nfor point in PointIterator(ph)\n    point === nothing && continue # Skip any points that weren't found\n    reinit!(pointvalues, point)   # Update pointvalues\n    # ...\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.PointLocation","page":"Postprocessing","title":"Ferrite.PointLocation","text":"PointLocation\n\nElement of a PointIterator, typically used to reinitialize PointValues. Fields:\n\ncid::Int: ID of the cell containing the point\nlocal_coord::Vec: the local (reference) coordinate of the point\ncoords::Vector{Vec}: the coordinates of the cell\n\n\n\n\n\n","category":"type"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"evaluate_at_grid_nodes","category":"page"},{"location":"reference/export/#Ferrite.evaluate_at_grid_nodes","page":"Postprocessing","title":"Ferrite.evaluate_at_grid_nodes","text":"evaluate_at_grid_nodes(dh::AbstractDofHandler, u::Vector{T}, fieldname::Symbol) where T\n\nEvaluate the approximated solution for field fieldname at the node coordinates of the grid given the Dof handler dh and the solution vector u.\n\nReturn a vector of length getnnodes(grid) where entry i contains the evalutation of the approximation in the coordinate of node i. If the field does not live on parts of the grid, the corresponding values for those nodes will be returned as NaNs.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#VTK-Export","page":"Postprocessing","title":"VTK Export","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"vtk_grid(filename::AbstractString, grid::Grid{dim,C,T}; compress::Bool) where {dim,C,T} \nvtk_point_data\nvtk_cellset\nvtk_cell_data_colors","category":"page"},{"location":"reference/export/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{C}, Tuple{dim}, Tuple{AbstractString, Grid{dim, C, T}}} where {dim, C, T}","page":"Postprocessing","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString, grid::Grid; kwargs...)\nvtk_grid(filename::AbstractString, dh::DofHandler; kwargs...)\n\nCreate a unstructured VTK grid from grid (alternatively from the grid stored in dh).  Return a DatasetFile that data can be appended to, see  vtk_point_data and vtk_cell_data. The keyword arguments are forwarded to WriteVTK.vtk_grid, see  Data Formatting Options\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#WriteVTK.vtk_point_data","page":"Postprocessing","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::Vector{<:AbstractTensor}, name)\n\nWrite the tensor field data to the vtk file. Two-dimensional tensors are padded with zeros.\n\nFor second order tensors the following indexing ordering is used: [11, 22, 33, 23, 13, 12, 32, 31, 21]. This is the default Voigt order in Tensors.jl.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Ferrite.vtk_cellset","page":"Postprocessing","title":"Ferrite.vtk_cellset","text":"vtk_cellset(vtk, grid::Grid)\n\nExport all cell sets in the grid. Each cell set is exported with vtk_cell_data with value 1 if the cell is in the set, and 0 otherwise.\n\n\n\n\n\nvtk_cellset(vtk, grid::Grid, cellset::String)\n\nExport the cell set specified by cellset as cell data with value 1 if the cell is in the set and 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Ferrite.vtk_cell_data_colors","page":"Postprocessing","title":"Ferrite.vtk_cell_data_colors","text":"vtk_cell_data_colors(vtkfile, cell_colors, name=\"coloring\")\n\nWrite cell colors (see create_coloring) to a VTK file for visualization.\n\nIn case of coloring a subset, the cells which are not part of the subset are represented as color 0.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/mapping/#Mapping-of-finite-elements","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"","category":"section"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"The shape functions and gradients stored in an FEValues object, is reinitialized for each cell by calling the reinit! function. The main part of this calculation, considers how to map the functions described on the reference cell, to the actual cell.","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"The geometric mapping of a finite element from the reference coordinates to the real coordinates is shown in the following illustration. ","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"(Image: mapping_figure)","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"This mapping is given by the geometric shape functions, hatN_i^g(boldsymbolxi), such that ","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    boldsymbolx(boldsymbolxi) = sum_i^N hatboldsymbolx_i hatN_i^g(boldsymbolxi) \n    boldsymbolJ = fracmathrmdboldsymbolxmathrmdboldsymbolxi = sum_i^N hatboldsymbolx_i otimes fracmathrmd hatN_i^gmathrmdboldsymbolxi\n    boldsymbolmathcalH =\n    fracmathrmd boldsymbolJmathrmd boldsymbolxi = sum_alpha=1^N hatboldsymbolx_alpha otimes fracmathrmd^2 hatN^g_alphamathrmd boldsymbolxi^2\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"where the defined boldsymbolJ is the jacobian of the mapping, and in some cases we will also need the corresponding hessian, boldsymbolmathcalH (3rd order tensor).","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"We require that the mapping from reference coordinates to real coordinates is diffeomorphic, meaning that we can express boldsymbolx = boldsymbolx(boldsymbolxi(boldsymbolx)), such that","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    fracmathrmdboldsymbolxmathrmdboldsymbolx = boldsymbolI = fracmathrmdboldsymbolxmathrmdboldsymbolxi cdot fracmathrmdboldsymbolximathrmdboldsymbolx \n    quadRightarrowquad \n    fracmathrmdboldsymbolximathrmdboldsymbolx = leftfracmathrmdboldsymbolxmathrmdboldsymbolxiright^-1 = boldsymbolJ^-1\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"Depending on the function interpolation, we may want different types of mappings to conserve certain properties of the fields. This results in the different mapping types described below.","category":"page"},{"location":"devdocs/mapping/#Identity-mapping","page":"Mapping of finite elements","title":"Identity mapping","text":"","category":"section"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"Ferrite.IdentityMapping","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"For scalar fields, we always use scalar base functions. For tensorial fields (non-scalar, e.g. vector-fields), the base functions can be constructed from scalar base functions, by using e.g. VectorizedInterpolation. From the perspective of the mapping, however, each component is mapped as an individual scalar base function. And for scalar base functions, we only require that the value of the base function is invariant to the element shape (real coordinate), and only depends on the reference coordinate, i.e. ","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    N(boldsymbolx) = hatN(boldsymbolxi(boldsymbolx))nonumber \n    mathrmgrad(N(boldsymbolx)) = fracmathrmdhatNmathrmdboldsymbolxi cdot boldsymbolJ^-1\nendalign*","category":"page"},{"location":"devdocs/mapping/#Covariant-Piola-mapping,-H(curl)","page":"Mapping of finite elements","title":"Covariant Piola mapping, H(curl)","text":"","category":"section"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"Ferrite.CovariantPiolaMapping","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"The covariant Piola mapping of a vectorial base function preserves the tangential components. For the value, the mapping is defined as ","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    boldsymbolN(boldsymbolx) = boldsymbolJ^-mathrmT cdot hatboldsymbolN(boldsymbolxi(boldsymbolx))\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"which yields the gradient,","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    mathrmgrad(boldsymbolN(boldsymbolx)) = boldsymbolJ^-T cdot fracmathrmd hatboldsymbolNmathrmd boldsymbolxi cdot boldsymbolJ^-1 - boldsymbolJ^-T cdot lefthatboldsymbolN(boldsymbolxi(boldsymbolx))cdot boldsymbolJ^-1 cdot boldsymbolmathcalHcdot boldsymbolJ^-1right\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"details: Derivation\nExpressing the gradient, mathrmgrad(boldsymbolN), in index notation,beginalign*\n    fracmathrmd N_imathrmd x_j = fracmathrmdmathrmd x_j leftJ^-mathrmT_ik hatN_kright = fracmathrmd J^-mathrmT_ikmathrmd x_j hatN_k + J^-mathrmT_ik  fracmathrmd hatN_kmathrmd xi_l J_lj^-1\nendalign*Except for a few elements, boldsymbolJ varies as a function of boldsymbolx. The derivative can be calculated as beginalign*\n    fracmathrmd J^-mathrmT_ikmathrmd x_j = fracmathrmd J^-mathrmT_ikmathrmd J_mn fracmathrmd J_mnmathrmd x_j = - J_km^-1 J_in^-T fracmathrmd J_mnmathrmd x_j nonumber \n    fracmathrmd J_mnmathrmd x_j = mathcalH_mno J_oj^-1\nendalign*","category":"page"},{"location":"devdocs/mapping/#Contravariant-Piola-mapping,-H(div)","page":"Mapping of finite elements","title":"Contravariant Piola mapping, H(div)","text":"","category":"section"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"Ferrite.ContravariantPiolaMapping","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"The covariant Piola mapping of a vectorial base function preserves the normal components. For the value, the mapping is defined as ","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    boldsymbolN(boldsymbolx) = fracboldsymbolJdet(boldsymbolJ) cdot hatboldsymbolN(boldsymbolxi(boldsymbolx))\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"This gives the gradient","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"beginalign*\n    mathrmgrad(boldsymbolN(boldsymbolx)) = boldsymbolmathcalHcdotboldsymbolJ^-1  fracboldsymbolI underlineotimes boldsymbolI cdot hatboldsymbolNdet(boldsymbolJ)\n    - leftfracboldsymbolJ cdot hatboldsymbolNdet(boldsymbolJ)right otimes leftboldsymbolJ^-T  boldsymbolmathcalH cdot boldsymbolJ^-1right\n    + boldsymbolJ cdot fracmathrmd hatboldsymbolNmathrmd boldsymbolxi cdot fracboldsymbolJ^-1det(boldsymbolJ)\nendalign*","category":"page"},{"location":"devdocs/mapping/","page":"Mapping of finite elements","title":"Mapping of finite elements","text":"details: Derivation\nExpressing the gradient, mathrmgrad(boldsymbolN), in index notation,beginalign*\n    fracmathrmd N_imathrmd x_j = fracmathrmdmathrmd x_j leftfracJ_ikdet(boldsymbolJ) hatN_kright =nonumber\n    = fracmathrmd J_ikmathrmd x_j frachatN_kdet(boldsymbolJ) \n    - fracmathrmd det(boldsymbolJ)mathrmd x_j fracJ_ik hatN_kdet(boldsymbolJ)^2\n    + fracJ_ikdet(boldsymbolJ)  fracmathrmd hatN_kmathrmd xi_l J_lj^-1 \n    = mathcalH_ikl J^-1_lj frachatN_kdet(boldsymbolJ) \n    - J^-T_mn mathcalH_mnl J^-1_lj fracJ_ik hatN_kdet(boldsymbolJ)\n    + fracJ_ikdet(boldsymbolJ)  fracmathrmd hatN_kmathrmd xi_l J_lj^-1\nendalign*","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"topics/assembly/#man-assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"When the local stiffness matrix and force vector have been calculated they should be assembled into the global stiffness matrix and the global force vector. This is just a matter of adding the local matrix and vector to the global one, at the correct place. Consider e.g. assembling the local stiffness matrix ke and the local force vector fe into the global K and f respectively. These should be assembled into the row/column which corresponds to the degrees of freedom for the cell:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"where celldofs is the vector containing the degrees of freedom for the cell. The method above is very inefficient ‚Äì it is especially costly to index into the sparse matrix K directly. Therefore we will instead use an Assembler that will help with the assembling of both the global stiffness matrix and the global force vector. It is also often convenient to create the sparse matrix just once, and reuse the allocated matrix. This is useful for e.g. iterative solvers or time dependent problems where the sparse matrix structure, or Sparsity Pattern will stay the same in every iteration/ time step.","category":"page"},{"location":"topics/assembly/#Sparsity-Pattern","page":"Assembly","title":"Sparsity Pattern","text":"","category":"section"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler we can obtain the corresponding sparse matrix by using the create_sparsity_pattern function. This will setup a SparseMatrixCSC with stored values on all the places corresponding to the degree of freedom numbering in the DofHandler. This means that when we assemble into the global stiffness matrix there is no need to change the internal representation of the sparse matrix since the sparse structure will not change.","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"Often the finite element problem is symmetric and will result in a symmetric sparse matrix. This information is often something that the sparse solver can take advantage of. If the solver only needs half the matrix there is no need to assemble both halves. For this purpose there is a create_symmetric_sparsity_pattern function that will only create the upper half of the matrix, and return a Symmetric wrapped SparseMatrixCSC.","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler dh we can obtain the (symmetric) sparsity pattern as","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nK = create_symmetric_sparsity_pattern(dh)","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"The returned sparse matrix will be used together with an Assembler, which assembles efficiently into the matrix, without modifying the internal representation.","category":"page"},{"location":"topics/assembly/#Assembler","page":"Assembly","title":"Assembler","text":"","category":"section"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"Assembling efficiently into the sparse matrix requires some extra workspace. This workspace is allocated in an Assembler. start_assemble is used to create an Assembler:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"A = start_assemble(K)\nA = start_assemble(K, f)","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"where K is the global stiffness matrix, and f the global force vector. It is optional to pass the force vector to the assembler ‚Äì sometimes there is no need to assemble a global force vector.","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"The assemble! function is used to assemble element contributions to the assembler. For example, to assemble the element tangent stiffness ke and the element force vector fe to the assembler A, the following code can be used:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"assemble!(A, celldofs, ke)\nassemble!(A, celldofs, ke, fe)","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"which perform the following operations in an efficient manner:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"topics/assembly/#Pseudo-code-for-efficient-assembly","page":"Assembly","title":"Pseudo-code for efficient assembly","text":"","category":"section"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"Quite often the same sparsity pattern can be reused multiple times. For example:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"For time-dependent problems the pattern can be reused for all timesteps\nFor non-linear problems the pattern can be reused for all iterations","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"In such cases it is enough to construct the global matrix K once. Below is some pseudo-code for how to do this for a time-dependent problem:","category":"page"},{"location":"topics/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nf = zeros(ndofs(dh))\n\nfor t in 1:timesteps\n    A = start_assemble(K, f) # start_assemble zeroes K and f\n    for cell in CellIterator(dh)\n        ke, fe = element_routine(...)\n        assemble!(A, celldofs(cell), ke, fe)\n    end\n    # Apply boundary conditions and solve for u(t)\n    # ...\nend","category":"page"},{"location":"howto/#How-to-guides","page":"How-to guides","title":"How-to guides","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"This page gives an overview of the how-to guides. How-to guides address various common tasks one might want to do in a finite element program. Many of the guides are extensions, or build on top of, the tutorials and, therefore, some familiarity with Ferrite is assumed.","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"","category":"page"},{"location":"howto/#[Post-processing-and-visualization](postprocessing.md)","page":"How-to guides","title":"Post processing and visualization","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"This guide builds on top of Tutorial 1: Heat equation and discusses various post processsing techniques with the goal of visualizing primary fields (the finite element solution) and secondary quantities (e.g. fluxes, stresses, etc.). Concretely, this guide answers:","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"How to visualize data from quadrature points?\nHow to evaluate the finite element solution, or secondary quantities, in arbitrary points of the domain?","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"","category":"page"},{"location":"howto/#[Multi-threaded-assembly](threaded_assembly.md)","page":"How-to guides","title":"Multi-threaded assembly","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"This guide modifies Tutorial 2: Linear elasticity such that the program is using multi-threading to parallelize the assembly procedure. Concretely this shows how to use grid coloring and \"scratch values\" in order to use multi-threading without running into race-conditions.","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"","category":"page"},{"location":"devdocs/elements/#devdocs-elements","page":"Elements and cells","title":"Elements and cells","text":"","category":"section"},{"location":"devdocs/elements/#Type-definitions","page":"Elements and cells","title":"Type definitions","text":"","category":"section"},{"location":"devdocs/elements/","page":"Elements and cells","title":"Elements and cells","text":"Elements or cells are subtypes of AbstractCell{dim,N,M}. They are parametrized by the dimension of their nodes via dim, the number of nodes N and the number of faces M.","category":"page"},{"location":"devdocs/elements/#Required-methods-to-implement-for-all-subtypes-of-AbstractCell-to-define-a-new-element","page":"Elements and cells","title":"Required methods to implement for all subtypes of AbstractCell to define a new element","text":"","category":"section"},{"location":"devdocs/elements/","page":"Elements and cells","title":"Elements and cells","text":"Ferrite.vertices(::Ferrite.AbstractCell)\nFerrite.edges(::Ferrite.AbstractCell)\nFerrite.reference_faces(::Ferrite.AbstractRefShape)\nFerrite.faces(::Ferrite.AbstractCell)\nFerrite.default_interpolation(::Ferrite.AbstractCell)","category":"page"},{"location":"devdocs/elements/#Ferrite.vertices-Tuple{Ferrite.AbstractCell}","page":"Elements and cells","title":"Ferrite.vertices","text":"Ferrite.vertices(::AbstractCell)\n\nReturns a tuple with the node indices (of the nodes in a grid) for each vertex in a given cell. This function induces the VertexIndex, where the second index  corresponds to the local index into this tuple.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.edges-Tuple{Ferrite.AbstractCell}","page":"Elements and cells","title":"Ferrite.edges","text":"Ferrite.edges(::AbstractCell)\n\nReturns a tuple of 2-tuples containing the ordered node indices (of the nodes in a grid) corresponding to the vertices that define an oriented edge. This function induces the  EdgeIndex, where the second index corresponds to the local index into this tuple.\n\nNote that the vertices are sufficient to define an edge uniquely.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.reference_faces-Tuple{Ferrite.AbstractRefShape}","page":"Elements and cells","title":"Ferrite.reference_faces","text":"reference_faces(::AbstractRefShape)\n\nReturns a tuple of n-tuples containing the ordered local node indices corresponding to the vertices that define an oriented face.\n\nAn oriented face is a face with the first node having the local index and the other nodes spanning such that the normal to the face is pointing outwards.\n\nNote that the vertices are sufficient to define a face uniquely.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.faces-Tuple{Ferrite.AbstractCell}","page":"Elements and cells","title":"Ferrite.faces","text":"Ferrite.faces(::AbstractCell)\n\nReturns a tuple of n-tuples containing the ordered node indices (of the nodes in a grid) corresponding to the vertices that define an oriented face. This function induces the  FaceIndex, where the second index corresponds to the local index into this tuple.\n\nAn oriented face is a face with the first node having the local index and the other nodes spanning such that the normal to the face is pointing outwards.\n\nNote that the vertices are sufficient to define a face uniquely.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.default_interpolation-Tuple{Ferrite.AbstractCell}","page":"Elements and cells","title":"Ferrite.default_interpolation","text":"Ferrite.default_interpolation(::AbstractCell)::Interpolation\n\nReturns the interpolation which defines the geometry of a given cell.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Common-utilities-and-definitions-when-working-with-grids-internally.","page":"Elements and cells","title":"Common utilities and definitions when working with grids internally.","text":"","category":"section"},{"location":"devdocs/elements/","page":"Elements and cells","title":"Elements and cells","text":"Ferrite.BoundaryIndex\nFerrite.boundaryfunction(::Type{<:Ferrite.BoundaryIndex})\nFerrite.get_coordinate_eltype(::Ferrite.AbstractGrid)\nFerrite.get_coordinate_eltype(::Node)\nFerrite.toglobal\nFerrite.sortface\nFerrite.sortedge\nFerrite.getfaceedges\nFerrite.getfacevertices\nFerrite.getedgevertices\nFerrite.getfaceinstances\nFerrite.getedgeinstances\nFerrite.getvertexinstances\nFerrite.filterfaces\nFerrite.filteredges\nFerrite.filtervertices","category":"page"},{"location":"devdocs/elements/#Ferrite.BoundaryIndex","page":"Elements and cells","title":"Ferrite.BoundaryIndex","text":"Abstract type which is used as identifier for faces, edges and verices\n\n\n\n\n\n","category":"type"},{"location":"devdocs/elements/#Ferrite.boundaryfunction-Tuple{Type{<:Ferrite.BoundaryIndex}}","page":"Elements and cells","title":"Ferrite.boundaryfunction","text":"boundaryfunction(::Type{<:BoundaryIndex})\n\nHelper function to dispatch on the correct entity from a given boundary index.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.get_coordinate_eltype-Tuple{Ferrite.AbstractGrid}","page":"Elements and cells","title":"Ferrite.get_coordinate_eltype","text":"Return the number type of the nodal coordinates.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.get_coordinate_eltype-Tuple{Node}","page":"Elements and cells","title":"Ferrite.get_coordinate_eltype","text":"get_coordinate_eltype(::Node)\n\nGet the data type of the components of the nodes coordinate.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/elements/#Ferrite.toglobal","page":"Elements and cells","title":"Ferrite.toglobal","text":"toglobal(grid::AbstractGrid, vertexidx::VertexIndex) -> Int\ntoglobal(grid::AbstractGrid, vertexidx::Vector{VertexIndex}) -> Vector{Int}\n\nThis function takes the local vertex representation (a VertexIndex) and looks up the unique global id (an Int).\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.sortface","page":"Elements and cells","title":"Ferrite.sortface","text":"sortface(face::Tuple{Int})\nsortface(face::Tuple{Int,Int})\nsortface(face::Tuple{Int,Int,Int})\nsortface(face::Tuple{Int,Int,Int,Int})\n\nReturns the unique representation of a face. Here the unique representation is the sorted node index tuple. Note that in 3D we only need indices to uniquely identify a face, so the unique representation is always a tuple length 3.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.sortedge","page":"Elements and cells","title":"Ferrite.sortedge","text":"sortedge(edge::Tuple{Int,Int})\n\nReturns the unique representation of an edge and its orientation. Here the unique representation is the sorted node index tuple. The orientation is true if the edge is not flipped, where it is false if the edge is flipped.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getfaceedges","page":"Elements and cells","title":"Ferrite.getfaceedges","text":"getfaceedges(grid::AbstractGrid, face::FaceIndex)\ngetfaceedges(cell::AbstractCell, face::FaceIndex)\n\nReturns the edges represented as Set{EdgeIndex} in a given face represented as FaceIndex.\n\njulia> using Ferrite; using Ferrite: getfaceedges\n\njulia> grid = generate_grid(Tetrahedron, (2,1,1));\n\njulia> getfaceedges(grid, FaceIndex(4,2))\nSet{EdgeIndex} with 3 elements:\n  EdgeIndex((4, 4))\n  EdgeIndex((4, 5))\n  EdgeIndex((4, 1))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getfacevertices","page":"Elements and cells","title":"Ferrite.getfacevertices","text":"getfacevertices(grid::AbstractGrid, face::FaceIndex)\ngetfacevertices(cell::AbstractCell, face::FaceIndex)\n\nReturns the vertices represented as Set{VertexIndex} in a given face represented as FaceIndex.\n\njulia> using Ferrite; using Ferrite: getfacevertices\n\njulia> grid = generate_grid(Tetrahedron, (2,1,1));\n\njulia> getfacevertices(grid, FaceIndex(4,2))\nSet{VertexIndex} with 3 elements:\n  VertexIndex((4, 2))\n  VertexIndex((4, 4))\n  VertexIndex((4, 1))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getedgevertices","page":"Elements and cells","title":"Ferrite.getedgevertices","text":"getedgevertices(grid::AbstractGrid, edge::EdgeIndex)\ngetedgevertices(cell::AbstractCell, edge::EdgeIndex)\n\nReturns the vertices represented as Set{VertexIndex} in a given edge represented as EdgeIndex.\n\njulia> using Ferrite; using Ferrite: getedgevertices\n\njulia> grid = generate_grid(Tetrahedron, (2,1,1));\n\njulia> getedgevertices(grid, EdgeIndex(4,2))\nSet{EdgeIndex} with 2 elements:\n  VertexIndex((4, 2))\n  VertexIndex((4, 3))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getfaceinstances","page":"Elements and cells","title":"Ferrite.getfaceinstances","text":"getfaceinstances(grid::AbstractGrid, topology::ExclusiveTopology, face::FaceIndex)\n\nReturns all the faces as Set{FaceIndex} that share all their vertices with a given face represented as FaceIndex. The returned set includes the input face.\n\njulia> using Ferrite; using Ferrite: getfaceinstances\n\njulia> grid = generate_grid(Tetrahedron, (2,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> getfaceinstances(grid, topology, FaceIndex(4,2))\nSet{FaceIndex} with 2 elements:\nFaceIndex((6, 4))\nFaceIndex((4, 2))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getedgeinstances","page":"Elements and cells","title":"Ferrite.getedgeinstances","text":"getedgeinstances(grid::AbstractGrid, topology::ExclusiveTopology, edge::EdgeIndex)\n\nReturns all the edges as Set{EdgeIndex} that share all their vertices with a given edge represented as EdgeIndex. The returned set includes the input edge.\n\njulia> using Ferrite; using Ferrite: getedgeinstances\n\njulia> grid = generate_grid(Tetrahedron, (2,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> getedgeinstances(grid, topology, EdgeIndex(4,2))\nSet{EdgeIndex} with 3 elements:\nEdgeIndex((4, 2))\nEdgeIndex((9, 6))\nEdgeIndex((7, 6))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.getvertexinstances","page":"Elements and cells","title":"Ferrite.getvertexinstances","text":"getvertexinstances(grid::AbstractGrid, topology::ExclusiveTopology, vertex::EdgeIndex)\n\nReturns all the vertices as Set{::VertexIndex} that use a given vertex represented as VertexIndex in all cells. The returned set includes the input vertex.\n\njulia> using Ferrite; using Ferrite: getvertexinstances\n\njulia> grid = generate_grid(Tetrahedron,(2,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> getvertexinstances(grid, topology, VertexIndex(4,2))\nSet{VertexIndex} with 8 elements:\nVertexIndex((7, 4))\nVertexIndex((10, 4))\nVertexIndex((12, 4))\nVertexIndex((6, 3))\nVertexIndex((4, 2))\nVertexIndex((9, 4))\nVertexIndex((11, 4))\nVertexIndex((8, 4))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.filterfaces","page":"Elements and cells","title":"Ferrite.filterfaces","text":"filterfaces(grid::AbstractGrid, faces::Set{FaceIndex}, f::Function; all::Bool=true)\n\nReturns the faces in faces that satisfy f as a Set{FaceIndex}. all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite; using Ferrite: filterfaces\n\njulia> grid = generate_grid(Tetrahedron, (2,2,2));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryfaceset!(grid, topology, \"b\", x -> true);\n\njulia> filterfaces(grid, grid.facesets[\"b\"], x -> x[3] ‚âà -1)\nSet{FaceIndex} with 8 elements:\nFaceIndex((7, 1))\nFaceIndex((3, 1))\nFaceIndex((21, 1))\nFaceIndex((13, 1))\nFaceIndex((19, 1))\nFaceIndex((15, 1))\nFaceIndex((1, 1))\nFaceIndex((9, 1))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.filteredges","page":"Elements and cells","title":"Ferrite.filteredges","text":"filteredges(grid::AbstractGrid, edges::Set{EdgeIndex}, f::Function; all::Bool=true)\n\nReturns the edges in edges that satisfy f as a Set{EdgeIndex}. all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite; using Ferrite: filteredges\n\njulia> grid = generate_grid(Tetrahedron, (1,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryedgeset!(grid, topology, \"b\", x -> true);\n\njulia> filteredges(grid, grid.edgesets[\"b\"], x -> x[3] ‚âà -1)\nSet{EdgeIndex} with 8 elements:\nEdgeIndex((1, 2))\nEdgeIndex((3, 2))\nEdgeIndex((4, 3))\nEdgeIndex((1, 3))\nEdgeIndex((3, 3))\nEdgeIndex((1, 1))\nEdgeIndex((3, 1))\nEdgeIndex((2, 3))\n\n\n\n\n\n","category":"function"},{"location":"devdocs/elements/#Ferrite.filtervertices","page":"Elements and cells","title":"Ferrite.filtervertices","text":"filtervertices(grid::AbstractGrid, vertices::Set{VertexIndex}, f::Function; all::Bool=true)\n\nReturns the vertices in vertices that satisfy f as a Set{VertexIndex}. all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite; using Ferrite: filtervertices\n\njulia> grid = generate_grid(Tetrahedron,(1,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryvertexset!(grid, topology, \"b\", x -> true);\n\njulia> filtervertices(grid, grid.vertexsets[\"b\"], x -> x[3] ‚âà -1)\nSet{VertexIndex} with 12 elements:\nVertexIndex((2, 3))\nVertexIndex((4, 3))\nVertexIndex((4, 1))\nVertexIndex((3, 3))\nVertexIndex((3, 2))\nVertexIndex((1, 1))\nVertexIndex((2, 1))\nVertexIndex((3, 1))\nVertexIndex((1, 3))\nVertexIndex((5, 1))\nVertexIndex((1, 2))\nVertexIndex((6, 1))\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference overview","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference overview","title":"Reference overview","text":"Pages = [\n    \"quadrature.md\",\n    \"interpolations.md\",\n    \"fevalues.md\",\n    \"dofhandler.md\",\n    \"assembly.md\",\n    \"boundary_conditions.md\",\n    \"grid.md\",\n    \"export.md\",\n    \"utils.md\",\n]","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"topics/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"PDEs can in general be subjected to a number of constraints, ","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"g_I(underlinea) = 0 quad I = 1 text to  n_c","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"where g are (non-linear) constraint equations, underlinea is a vector of the degrees of freedom, and n_c is the number of constraints. There are many ways to enforce these constraints, e.g. penalty methods and Lagrange multiplier methods. ","category":"page"},{"location":"topics/constraints/#Affine-constraints","page":"Constraints","title":"Affine constraints","text":"","category":"section"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"Affine or linear constraints can be handled directly in Ferrite. Such constraints can typically be expressed as:","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"a_1 =  5a_2 + 3a_3 + 1 \na_4 =  2a_3 + 6a_5 \ndots","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"where a_1, a_2 etc. are system degrees of freedom. In Ferrite, we can account for such constraint using the ConstraintHandler:","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"ch = ConstraintHandler(dh)\nlc1 = AffineConstraint(1, [2 => 5.0, 3 => 3.0], 1)\nlc2 = AffineConstraint(1, [3 => 2.0, 5 => 6.0], 0)\nadd!(ch, lc1)\nadd!(ch, lc2)","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"Affine constraints will affect the sparsity pattern of the stiffness matrix, and as such, it is important to also include  the ConstraintHandler as an argument when creating the sparsity pattern:","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"K = create_sparsity_pattern(dh, ch)","category":"page"},{"location":"topics/constraints/#Solving-linear-problems","page":"Constraints","title":"Solving linear problems","text":"","category":"section"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"To solve the system underlineunderlineKunderlinea=underlinef, account for affine constraints the same way as for  Dirichlet boundary conditions; first call apply!(K, f, ch). This will condense K and f inplace (i.e no new matrix will be created). Note however that we must also call apply! on the solution vector after  solving the system to enforce the affine constraints:","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"# ...\n# Assemble K and f...\n\napply!(K, f, ch)\na = K\\f\napply!(a, ch) # enforces affine constraints\n","category":"page"},{"location":"topics/constraints/#Solving-nonlinear-problems","page":"Constraints","title":"Solving nonlinear problems","text":"","category":"section"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"It is important to check the residual after applying boundary conditions when  solving nonlinear problems with affine constraints.  apply_zero!(K, r, ch) modifies the residual entries for dofs that are involved  in constraints to account for constraint forces.  The following pseudo-code shows a typical pattern for solving a non-linear problem with Newton's method:","category":"page"},{"location":"topics/constraints/","page":"Constraints","title":"Constraints","text":"a = initial_guess(...)  # Make any initial guess for a here, e.g. `a=zeros(ndofs(dh))`\napply!(a, ch)           # Make the guess fulfill all constraints in `ch`\nfor iter in 1:maxiter\n    doassemble!(K, r, ...)  # Assemble the residual, r, and stiffness, K=‚àÇr/‚àÇa.\n    apply_zero!(K, r, ch)   # Modify `K` and `r` to account for the constraints. \n    check_convergence(r, ...) && break # Only check convergence after `apply_zero!(K, r, ch)`\n    Œîa = K \\ r              # Calculate the (negative) update\n    apply_zero!(Œîa, ch)     # Change the constrained values in `Œîa` such that `a-Œîa`\n                            # fulfills constraints if `a` did.\n    a .-= Œîa\nend","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"topics/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"topics/grid/#Mesh-Reading","page":"Grid","title":"Mesh Reading","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"A Ferrite Grid can be generated with the generate_grid function.  More advanced meshes can be imported with the  FerriteMeshParser.jl (from Abaqus input files), or even created and translated with the Gmsh.jl and FerriteGmsh.jl package, respectively.","category":"page"},{"location":"topics/grid/#FerriteGmsh","page":"Grid","title":"FerriteGmsh","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"FerriteGmsh.jl supports all defined cells with an alias in Ferrite.jl as well as the 3D Serendipity Cell{3,20,6}. Either, a mesh is created on the fly with the gmsh API or a mesh in .msh or .geo format can be read and translated with the FerriteGmsh.togrid function.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"FerriteGmsh.togrid","category":"page"},{"location":"topics/grid/#FerriteGmsh.togrid","page":"Grid","title":"FerriteGmsh.togrid","text":"togrid(filename::String; domain=\"\")\n\nOpen the Gmsh file filename (ie a .geo or .msh file) and return the corresponding Ferrite.Grid.\n\n\n\n\n\ntogrid(; domain=\"\")\n\nGenerate a Ferrite.Grid from the current active/open model in the Gmsh library.\n\n\n\n\n\n","category":"function"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"FerriteGmsh.jl supports currently the translation of cellsets and facesets. Such sets are defined in Gmsh as PhysicalGroups of dimension dim and dim-1, respectively. In case only a part of the mesh is the domain, the domain can be specified by providing the keyword argument domain the name of the PhysicalGroups in the FerriteGmsh.togrid function.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"note: Why you should read a .msh file\nReading a .msh file is the advertised way, since otherwise you remesh whenever you run the code. Further, if you choose to read the grid directly from the current model of the gmsh API you get artificial nodes, which doesn't harm the FE computation, but maybe distort your sophisticated grid operations (if present). For more information, see this issue.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"If you want to read another, not yet supported cell from gmsh, consider to open a PR at FerriteGmsh that extends the gmshtoferritecell dict and if needed, reorder the element nodes by dispatching FerriteGmsh.translate_elements. The reordering of nodes is necessary if the Gmsh ordering doesn't match the one from Ferrite. Gmsh ordering is documented here. For an exemplary usage of Gmsh.jl and FerriteGmsh.jl, consider the Stokes flow and Incompressible Navier-Stokes Equations via DifferentialEquations.jl example.","category":"page"},{"location":"topics/grid/#FerriteMeshParser","page":"Grid","title":"FerriteMeshParser","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"FerriteMeshParser.jl converts the mesh in an Abaqus input file (.inp) to a Ferrite.Grid with its function get_ferrite_grid. The translations for most of Abaqus' standard 2d and 3d continuum elements to a Ferrite.Cell are defined. Custom translations can be given as input, which can be used to import other (custom) elements or to override the default translation.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"FerriteMeshParser.get_ferrite_grid","category":"page"},{"location":"topics/grid/#FerriteMeshParser.get_ferrite_grid","page":"Grid","title":"FerriteMeshParser.get_ferrite_grid","text":"function get_ferrite_grid(\n    filename; \n    meshformat=AutomaticMeshFormat(), \n    user_elements=Dict{String,DataType}(), \n    generate_facesets=true\n    )\n\nCreate a Ferrite.Grid by reading in the file specified by filename.\n\nOptional arguments:\n\nmeshformat: Which format the mesh    is given in, normally automatically detected by the file extension\nuser_elements: Used to add extra elements not supported,   might require a separate cell constructor.\ngenerate_facesets: Should facesets be automatically generated from all nodesets?\n\n\n\n\n\n","category":"function"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"If you are missing the translation of an Abaqus element that is equivalent to a Ferrite.Cell, consider to open an issue or a pull request. ","category":"page"},{"location":"topics/grid/#Grid-Datastructure","page":"Grid","title":"Grid Datastructure","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"In Ferrite a Grid is a collection of Nodes and Cells and is parameterized in its physical dimensionality and cell type. Nodes are points in the physical space and can be initialized by a N-Tuple, where N corresponds to the dimensions.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"n1 = Node((0.0, 0.0))","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Cells are defined based on the Node IDs. Hence, they collect IDs in a N-Tuple. Consider the following 2D mesh:","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"(Image: global mesh)","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"The cells of the grid can be described in the following way","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"julia> cells = [\n              Quadrilateral((1,2,5,4)),\n              Quadrilateral((2,3,6,5)),\n              Quadrilateral((4,5,8,7)),\n              Quadrilateral((5,6,9,8))\n       ]","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"where each Quadrilateral, which is a subtype of AbstractCell saves in the field nodes the tuple of node IDs. Additionally, the data structure Grid can hold node-, face- and cellsets.  All of these three sets are defined by a dictionary that maps a string key to a Set.  For the special case of node- and cellsets the dictionary's value is of type Set{Int}, i.e. a keyword is mapped to a node or cell ID, respectively. ","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Facesets are a more elaborate construction. They map a String key to a Set{FaceIndex}, where each FaceIndex consists of (global_cell_id, local_face_id). In order to understand the local_face_id properly, one has to consider the reference space of the element, which typically is spanned by a product of the interval -1 1 and in this particular example -1 1 times -1 1.  In this space a local numbering of nodes and faces exists, i.e.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"(Image: local element)","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"The example shows a local face ID ordering, defined as:","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"faces(::Lagrange{2,RefCube,1}) = ((1,2), (2,3), (3,4), (4,1))","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Other face ID definitions can be found in the src files in the corresponding faces dispatch.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"The highlighted face, i.e. the two lines from node ID 3 to 6 and from 6 to 9, on the right hand side of our test mesh can now be described as","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"julia> faces = [\n           (3,6),\n           (6,9)\n       ]","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"The local ID can be constructed based on elements, corresponding faces and chosen interpolation, since the face ordering is interpolation dependent.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"julia> function compute_faceset(cells, global_faces, ip::Interpolation{dim}) where {dim}\n           local_faces = Ferrite.faces(ip)\n           nodes_per_face = length(local_faces[1])\n           d = Dict{NTuple{nodes_per_face, Int}, FaceIndex}()\n           for (c, cell) in enumerate(cells) # c is global cell number\n               for (f, face) in enumerate(local_faces) # f is local face number\n                   # store the global nodes for the particular element, local face combination\n                   d[ntuple(i-> cell.nodes[face[i]], nodes_per_face)] = FaceIndex(c, f)\n               end\n           end\n       \n           faces = Vector{FaceIndex}()\n           for face in global_faces\n               # lookup the element, local face combination for this face\n               push!(faces, d[face])\n           end\n       \n           return faces\n       end\n\njulia> interpolation = Lagrange{2, RefCube, 1}()\n\njulia> compute_faceset(cells, faces, interpolation)\nVector{FaceIndex} with 2 elements:\n  FaceIndex((2, 2))\n  FaceIndex((4, 2))","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Ferrite considers edges only in the three dimensional space. However, they share the concepts of faces in terms of (global_cell_id,local_edge_id) identifier.","category":"page"},{"location":"topics/grid/#AbstractGrid","page":"Grid","title":"AbstractGrid","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"It can be very useful to use a grid type for a certain special case, e.g. mixed cell types, adaptivity, IGA, etc. In order to define your own <: AbstractGrid you need to fulfill the AbstractGrid interface. In case that certain structures are preserved from the Ferrite.Grid type, you don't need to dispatch on your own type, but rather rely on the fallback AbstractGrid dispatch.","category":"page"},{"location":"topics/grid/#Example","page":"Grid","title":"Example","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"As a starting point, we choose a minimal working example from the test suite:","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"struct SmallGrid{dim,N,C<:Ferrite.AbstractCell} <: Ferrite.AbstractGrid{dim}\n    nodes_test::Vector{NTuple{dim,Float64}}\n    cells_test::NTuple{N,C}\nend","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Here, the names of the fields as well as their underlying datastructure changed compared to the Grid type. This would lead to the fact, that any usage with the utility functions and DoF management will not work. So, we need to feed into the interface how to handle this subtyped datastructure. We start with the utility functions that are associated with the cells of the grid:","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Ferrite.getcells(grid::SmallGrid) = grid.cells_test\nFerrite.getcells(grid::SmallGrid, v::Union{Int, Vector{Int}}) = grid.cells_test[v]\nFerrite.getncells(grid::SmallGrid{dim,N}) where {dim,N} = N\nFerrite.getcelltype(grid::SmallGrid) = eltype(grid.cells_test)\nFerrite.getcelltype(grid::SmallGrid, i::Int) = typeof(grid.cells_test[i])","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Next, we define some helper functions that take care of the node handling.","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Ferrite.getnodes(grid::SmallGrid) = grid.nodes_test\nFerrite.getnodes(grid::SmallGrid, v::Union{Int, Vector{Int}}) = grid.nodes_test[v]\nFerrite.getnnodes(grid::SmallGrid) = length(grid.nodes_test)\nFerrite.get_coordinate_eltype(::SmallGrid) = Float64\nFerrite.get_coordinate_type(::SmallGrid{dim}) where dim = Vec{dim,Float64}\nFerrite.nnodes_per_cell(grid::SmallGrid, i::Int=1) = Ferrite.nnodes(grid.cells_test[i])\nFerrite.n_faces_per_cell(grid::SmallGrid) = nfaces(eltype(grid.cells_test))","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"These definitions make many of Ferrites functions work out of the box, e.g. you can now call  getcoordinates(grid, cellid) on the SmallGrid. ","category":"page"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Now, you would be able to assemble the heat equation example over the new custom SmallGrid type. Note that this particular subtype isn't able to handle boundary entity sets and so, you can't describe boundaries with it. In order to use boundaries, e.g. for Dirichlet constraints in the ConstraintHandler, you would need to dispatch the AbstractGrid sets utility functions on SmallGrid.","category":"page"},{"location":"topics/grid/#Topology","page":"Grid","title":"Topology","text":"","category":"section"},{"location":"topics/grid/","page":"Grid","title":"Grid","text":"Ferrite.jl's Grid type offers experimental features w.r.t. topology information. The functions Ferrite.getneighborhood and Ferrite.faceskeleton are the interface to obtain topological information. The Ferrite.getneighborhood can construct lists of directly connected entities based on a given entity (CellIndex,FaceIndex,EdgeIndex,VertexIndex). The Ferrite.faceskeleton function can be used to evaluate integrals over material interfaces or computing element interface values such as jumps.","category":"page"},{"location":"changelog/#Ferrite-changelog","page":"Ferrite changelog","title":"Ferrite changelog","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Pages = [\"changelog.md\"]\nDepth = 2:2","category":"page"},{"location":"changelog/#Version-1.0.0-Work-in-progress,-release-date-TBD","page":"Ferrite changelog","title":"Version 1.0.0 - Work in progress, release date TBD","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Ferrite version 1.0 is a relatively large release, with a lot of new features, improvements, deprecations and some removals. These changes are made to make the code base more consistent and more suitable for future improvements. With this 1.0 release we are aiming for long time stability, and there is no breaking release 2.0 on the horizon.","category":"page"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Unfortunately this means that code written for Ferrite version 0.3 will have to be updated. All changes, with upgrade paths, are listed in the sections below. Since these sections include a lot of other information as well (new features, internal changes, ...) there is also a dedicated section about Upgrading code from Ferrite 0.3 to 1.0 which include the most common changes that are required. In addition, in all cases where possible, you will be presented with a descriptive error message telling you what needs to change.","category":"page"},{"location":"changelog/#Upgrading-code-from-Ferrite-0.3-to-1.0","page":"Ferrite changelog","title":"Upgrading code from Ferrite 0.3 to 1.0","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"This section give a short overview of the most common required changes. More details and motivation are included in the following sections (with links to issues/pull request for more discussion).","category":"page"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Interpolations: remove the first parameter (the reference dimension) and use new reference shapes.\nExamples:\n# Linear Lagrange interpolation for a line\n- Lagrange{1, RefCube, 1}()\n+ Lagrange{RefLine, 1}()\n\n# Linear Lagrange interpolation for a quadrilateral\n- Lagrange{2, RefCube, 1}()\n+ Lagrange{RefQuadrilateral, 1}()\n\n# Quadratic Lagrange interpolation for a triangle\n- Lagrange{2, RefTetrahedron, 2}()\n+ Lagrange{RefTriangle, 2}()\nFor vector valued problems it is now required to explicitly vectorize the interpolation using the new VectorizedInterpolation. This is required when passing the interpolation to CellValues and when adding fields to the DofHandler using add!. In both of these places the interpolation was implicitly vectorized in Ferrite 0.3.\nExamples:\n# Linear Lagrange interpolation for a vector problem on the triangle (vector dimension\n# same as the reference dimension)\nip_scalar = Lagrange{RefTriangle, 1}()\nip_vector = ip_scalar ^ 2 # or VectorizedInterpolation{2}(ip_scalar)\nQuadrature: remove the first parameter (the reference dimension) and use new reference shapes.\nExamples:\n# Quadrature for a line\n- QuadratureRule{1, RefCube}(quadrature_order)\n+ QuadratureRule{RefLine}(quadrature_order)\n\n# Quadrature for a quadrilateral\n- QuadratureRule{2, RefCube}(quadrature_order)\n+ QuadratureRule{RefQuadrilateral}(quadrature_order)\n\n# Quadrature for a tetrahedron\n- QuadratureRule{3, RefTetrahedron}(quadrature_order)\n+ QuadratureRule{RefTetrahedron}(quadrature_order)\nQuadrature for face integration (FaceValues): replace QuadratureRule{dim-1, reference_shape}(quadrature_order) with FaceQuadratureRule{reference_shape}(quadrature_order).\nExamples:\n# Quadrature for the faces of a quadrilateral\n- QuadratureRule{1, RefCube}(quadrature_order)\n+ FaceQuadratureRule{RefQuadrilateral}(quadrature_order)\n\n# Quadrature for the faces of a triangle\n- QuadratureRule{1, RefTetrahedron}(quadrature_order)\n+ FaceQuadratureRule{RefTriangle}(quadrature_order)\n\n# Quadrature for the faces of a hexhedron\n- QuadratureRule{2, RefCube}(quadrature_order)\n+ FaceQuadratureRule{RefHexahedron}(quadrature_order)\nCellValues: replace usage of CellScalarValues and CellVectorValues with CellValues. For vector valued problems the interpolation passed to CellValues should be vectorized to a VectorizedInterpolation (see above).\nExamples:\n# CellValues for a scalar problem with triangle elements\n- qr = QuadratureRule{2, RefTetrahedron}(quadrature_order)\n- ip = Lagrange{2, RefTetrahedron, 1}()\n- cv = CellScalarValues(qr, ip)\n+ qr = QuadratureRule{RefTriangle}(quadrature_order)\n+ ip = Lagrange{RefTriangle, 1}()\n+ cv = CellValues(qr, ip)\n\n# CellValues for a vector problem with hexahedronal elements\n- qr = QuadratureRule{3, RefCube}(quadrature_order)\n- ip = Lagrange{3, RefCube, 1}()\n- cv = CellVectorValues(qr, ip)\n+ qr = QuadratureRule{RefHexahedron}(quadrature_order)\n+ ip = Lagrange{RefHexahedron, 1}() ^ 3\n+ cv = CellValues(qr, ip)\nIf you use CellScalarValues or CellVectorValues in method signature you must replace them with CellValues. Note that the type parameters are different.\nExamples:\n- function do_something(cvs::CellScalarValues, cvv::CellVectorValues)\n+ function do_something(cvs::CellValues, cvv::CellValues)\nThe default geometric interpolation have changed from the function interpolation to always use linear Lagrange interpolation. If you use linear elements in the grid, and a higher order interpolation for the function you can now rely on the new default:\nqr = QuadratureRule(...)\n- ip_function = Lagrange{2, RefTetrahedron, 2}()\n- ip_geometry = Lagrange{2, RefTetrahedron, 1}()\n- cv = CellScalarValues(qr, ip_function, ip_geometry)\n+ ip_function = Lagrange{2, RefTetrahedron, 2}()\n+ cv = CellValues(qr, ip_function)\nand if you have quadratic (or higher order) elements in the grid you must now pass the corresponding interpolation to the constructor:\nqr = QuadratureRule(...)\n- ip_function = Lagrange{2, RefTetrahedron, 2}()\n- cv = CellScalarValues(qr, ip_function)\n+ ip_function = Lagrange{2, RefTetrahedron, 2}()\n+ ip_geometry = Lagrange{2, RefTetrahedron, 1}()\n+ cv = CellValues(qr, ip_function, ip_geometry)\nFaceValues: replace usage of FaceScalarValues and FaceVectorValues with FaceValues. For vector valued problems the interpolation passed to CellValues should be vectorized to a VectorizedInterpolation (see above). The input quadrature rule should be a FaceQuadratureRule instead of a QuadratureRule.\nExamples:\n# FaceValues for a scalar problem with triangle elements\n- qr = QuadratureRule{1, RefTetrahedron}(quadrature_order)\n- ip = Lagrange{2, RefTetrahedron, 1}()\n- cv = FaceScalarValues(qr, ip)\n+ qr = FaceQuadratureRule{RefTriangle}(quadrature_order)\n+ ip = Lagrange{RefTriangle, 1}()\n+ cv = FaceValues(qr, ip)\n\n# FaceValues for a vector problem with hexahedronal elements\n- qr = QuadratureRule{2, RefCube}(quadrature_order)\n- ip = Lagrange{3, RefCube, 1}()\n- cv = FaceVectorValues(qr, ip)\n+ qr = FaceQuadratureRule{RefHexahedron}(quadrature_order)\n+ ip = Lagrange{RefHexahedron, 1}() ^ 3\n+ cv = FaceValues(qr, ip)\nDofHandler construction: it is now required to pass the interpolation explicitly when adding new fields using add! (previously it was optional, defaulting to the default interpolation of the elements in the grid). For vector-valued fields the interpolation should be vectorized, instead of passing the number of components to add! as an integer.\nExamples:\ndh = DofHandler(grid) # grid with triangles\n\n# Vector field :u\n- add!(dh, :u, 2)\n+ add!(dh, :u, Lagrange{RefTriangle, 1}()^2)\n\n# Scalar field :p\n- add!(dh, :u, 1)\n+ add!(dh, :u, Lagrange{RefTriangle, 1}())","category":"page"},{"location":"changelog/#Added","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The DofHandler now support selectively adding fields on sub-domains (rather than the full domain). This new functionality is included with the new SubDofHandler struct, which, as the name suggest, is a DofHandler for a subdomain. (#624, #667, #735)\nNew reference shape structs RefLine, RefTriangle, RefQuadrilateral, RefTetrahedron, RefHexahedron, and RefPrism have been added. These encode the reference dimension, and will thus replace the old reference shapes for which it was necessary to always pair with an explicit dimension (i.e. RefLine replaces (RefCube, 1), RefTriangle replaces (RefTetrahedron, 2), etc.). For writing \"dimension independent code\" it is possible to use Ferrite.RefHypercube{dim} and Ferrite.RefSimplex{dim}. (#679)\nNew methods for adding entitysets that are located on the boundary of the grid: addboundaryfaceset!, addboundaryedgeset!, and addboundaryvertexset!. These work similar to addfaceset!, addedgeset!, and addvertexset!, but filters out all instances not on the boundary (this can be used to avoid accidental inclusion of internal entities in sets used for boundary conditions, for example). (#606)\nNew interpolation VectorizedInterpolation which vectorizes scalar interpolations for vector-valued problems. A VectorizedInterpolation is created from a (scalar) interpolation ip using either ip ^ dim or VectorizedInterpolation{dim}(ip). For convenience, the method VectorizedInterpolation(ip) vectorizes the interpolation to the reference dimension of the interpolation. (#694, #736)\nNew (scalar) interpolation Lagrange{RefQuadrilateral, 3}(), i.e. third order Lagrange interpolation for 2D quadrilaterals. (#701, #731)\nCellValues now support embedded elements. Specifically you can now embed elements with reference dimension 1 into spatial dimension 2 or 3, and elements with reference dimension 2 in to spatial dimension 3. (#651)\nCellValues now support (vector) interpolations with dimension different from the spatial dimension. (#651)\nFaceQuadratureRule have been added and should be used for FaceValues. A FaceQuadratureRule for integration of the faces of e.g. a triangle can be constructed by FaceQuadratureRule{RefTriangle}(order) (similar to how QuadratureRule is constructed). (#716)\nNew methods shape_value(::Interpolation, Œæ::Vec, i::Int) and shape_gradient(::Interpolation, Œæ::Vec, i::Int) for evaluating the value/gradient of the ith shape function of an interpolation in local reference coordinate Œæ. Note that these methods return the value/gradient wrt. the reference coordinate Œæ, whereas the corresponding methods for CellValues etc return the value/gradient wrt the spatial coordinate x. (#721)\nFaceIterator and FaceCache have been added. These work similarly to CellIterator and CellCache but are used to iterate over (boundary) face sets instead. These simplify boundary integrals in general, and in particular Neumann boundary conditions are more convenient to implement now that you can loop directly over the face set instead of checking all faces of a cell inside the element routine. (#495)\nThe ConstraintHandler now support adding Dirichlet boundary conditions on discontinuous interpolations. (#729)\nAll keyword arguments to vtk_grid are now passed on to WriteVTK.vtk_grid (only compress was supported earlier). (#687)\ncollect_periodic_faces now have a keyword argument tol that can be used to relax the default tolerance when necessary. (#749)\nVTK export now work with QuadraticHexahedron elements. (#714)","category":"page"},{"location":"changelog/#Changed","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The AbstractCell interface has been reworked. This change should not affect user code, but may in some cases be relevant for code parsing external mesh files. In particular, the generic Cell struct have been removed in favor of concrete cell implementations (Line, Triangle, ...). (#679, #712)\nTo upgrade replace any usage of Cell{...}(...) with calls to the concrete implementations.\nThe default geometric mapping in CellValues and FaceValues have changed. The new default is to always use Lagrange{refshape, 1}(), i.e. linear Lagrange polynomials, for the geometric interpolation. Previously, the function interpolation was (re) used also for the geometry interpolation. (#695)\nTo upgrade, if you relied on the previous default, simply pass the function interpolation also as the third argument (the geometric interpolation).\nAll interpolations are now categorized as either scalar or vector interpolations. All (previously) existing interpolations are scalar. (Scalar) interpolations must now be explicitly vectorized, using the new VectorizedInterpolation, when used for vector problems. (Previously implicit vectorization happened in the CellValues constructor, and when adding fields to the DofHandler). (#694)\nIt is now required to explicitly pass the interpolation to the DofHandler when adding a new field using add!. For vector fields the interpolation should be vectorized, instead of passing number of components as an integer. (#694)\nTo upgrade don't pass the dimension as an integer, and pass the interpolation explicitly. See more details in Upgrading code from Ferrite 0.3 to 1.0.\nInterpolations should now be constructed using the new reference shapes. Since the new reference shapes encode the reference dimension the first type parameter of interpolations have been removed. (#711) To upgrade replace e.g. Lagrange{1, RefCube, 1}() with Lagrange{RefLine, 1}(), and Lagrange{2, RefTetrahedron, 1}() with Lagrange{RefTriangle, 1}(), etc.\nQuadratureRules should now be constructed using the new reference shapes. Since the new reference shapes encode the reference dimension the first type parameter of QuadratureRule have been removed. (#711, #716) To upgrade replace e.g. QuadratureRule{1, RefCube}(order) with QuadratureRule{RefLine}(order), and QuadratureRule{2, RefTetrahedron}(1) with Lagrange{RefTriangle}(order), etc.\nCellScalarValues and CellVectorValues have been merged into CellValues, FaceScalarValues and FaceVectorValues have been merged into FaceValues, and PointScalarValues and PointVectorValues have been merged into PointValues. The differentiation between scalar and vector have thus been moved to the interpolation (see above). Note that previously CellValues, FaceValues, and PointValues where abstract types, but they are now concrete implementations with different type parameters. (#708) To upgrade, for scalar problems, it is enough to replace CellScalarValues with CellValues, FaceScalarValues with FaceValues and PointScalarValues with PointValues, respectively. For vector problems, make sure to vectorize the interpolation (see above) and then replace CellVectorValues with CellValues, FaceVectorValues with FaceValues, and PointVectorValues with PointValues.\nThe quadrature rule passed to FaceValues should now be of type FaceQuadratureRule rather than of type QuadratureRule. (#716) To upgrade replace the quadrature rule passed to FaceValues with a FaceQuadratureRule.","category":"page"},{"location":"changelog/#Deprecated","page":"Ferrite changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The rarely (if ever) used methods of function_value, function_gradient, function_divergence, and function_curl taking vectorized dof values as in put have been deprecated. (#698)\nThe function reshape_to_nodes have been deprecated in favor of evaluate_at_grid_nodes. (#703)\nstart_assemble(f, K) have been deprecated in favor of the \"canonical\" start_assemble(K, f). (#707)\nend_assemble have been deprecated in favor of finish_assemble. (#754)\nget_point_values have been deprecated in favor of evaluate_at_points. (#754)\ntransform! have been deprecated in favor of transform_coordinates!. (#754)","category":"page"},{"location":"changelog/#Removed","page":"Ferrite changelog","title":"Removed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"MixedDofHandler + FieldHandler have been removed in favor of DofHandler + SubDofHandler. Note that the syntax has changed, and note that SubDofHandler is much more capable compared to FieldHandler. Previously it was often required to pass both the MixedDofHandler and the FieldHandler to e.g. the assembly routine, but now it is enough to pass the SubDofHandler since it can be used for e.g. DoF queries etc. (#624, #667, #735)\nSome old methods to construct the L2Projector have been removed after being deprecated for several releases. (#697)\nThe option project_to_nodes have been removed from project(::L2Projector, ...). The returned values are now always ordered according to the projectors internal DofHandler. (#699)\nThe function compute_vertex_values have been removed. (#700)\nThe names getweights, getpoints, getcellsets, getnodesets, getfacesets, getedgesets, and getvertexsets have been removed from the list of exported names. (For now you can still use them by prefixing Ferrite., e.g. Ferrite.getweights.) (#754)","category":"page"},{"location":"changelog/#Fixed","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Topology construction have been generalized to, in particular, fix construction for 1D and for wedge elements. (#641, #670, #684)","category":"page"},{"location":"changelog/#Other-improvements","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Documentation:\nThe documentation is now structured according to the Diataxis framework. There is now also clear separation between tutorials (for teaching) and code gallery (for showing off). (#737, #756)\nNew section in the developer documentation that describes the (new) reference shapes and their numbering scheme. (#688)\nPerformance:\nFerrite.transform!(grid, f) (for transforming the node coordinates in the grid according to a function f) is now faster and allocates less. (#675)\nSlight performance improvement in construction of PointEvalHandler (faster reverse coordinate lookup). (#719)\nVarious performance improvements to topology construction. (#753)\nInternal improvements:\nThe dof distribution interface have been updated to support higher order elements (future work). (#627, #732, #733)\nThe AbstractGrid and AbstractDofHandler interfaces are now used more consistently internally. This will help with the implementation of distributed grids and DofHandlers. (#655)\nVTK export now uses the (geometric) interpolation directly when evaluating the finite element field instead of trying to work backwards how DoFs map to nodes. (#703)\nImproved bounds checking in assemble!. (#706)\nInternal methods Ferrite.value and Ferrite.derivative for computing the value/gradient of all shape functions have been removed. (#720)\nFerrite.create_incidence_matrix now work with any AbstractGrid (not just Grid). (#726)","category":"page"},{"location":"changelog/#Version-0.3.14-2023-04-03","page":"Ferrite changelog","title":"Version 0.3.14 - 2023-04-03","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Support reordering dofs of a MixedDofHandler by the built-in orderings FieldWise and ComponentWise. This includes support for reordering dofs of fields on subdomains. (#645)\nSupport specifying the coupling between fields in a MixedDofHandler when creating the sparsity pattern. (#650)\nSupport Metis dof reordering with coupling information for MixedDofHandler. (#650)\nPretty printing for MixedDofHandler and L2Projector. (#465)","category":"page"},{"location":"changelog/#Other-improvements-2","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The MixedDofHandler have gone through a performance review (see #629) and now performs the same as DofHandler. This was part of the push to merge the two DoF handlers. Since MixedDofHandler is strictly more flexible, and now equally performant, it will replace DofHandler in the next breaking release. (#637, #639, #642, #643, #656, #660)","category":"page"},{"location":"changelog/#Internal-changes","page":"Ferrite changelog","title":"Internal changes","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Changes listed here should not affect regular usage, but listed here in case you have been poking into Ferrite internals:","category":"page"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Ferrite.ndim(dh, fieldname) has been removed, use Ferrite.getfielddim(dh, fieldname) instead. (#658)\nFerrite.nfields(dh) has been removed, use length(Ferrite.getfieldnames(dh)) instead. (#444, #653)\ngetfielddims(::FieldHandler) and getfieldinterpolations(::FieldHandler) have been removed (#647, #659)","category":"page"},{"location":"changelog/#Version-0.3.13-2023-03-23","page":"Ferrite changelog","title":"Version 0.3.13 - 2023-03-23","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Support for classical trilinear and triquadratic wedge elements. (#581)\nSymmetric quadrature rules up to order 10 for prismatic elements. (#581)\nFiner granulation of dof distribution, allowing to distribute different amounts of dofs per entity. (#581)","category":"page"},{"location":"changelog/#Fixed-2","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Dof distribution for embedded elements. (#581)\nImprove numerical accuracy in shape function evaluation for the Lagrange{2,Tetrahedron,(3|4|5)} interpolations. (#582, #633)","category":"page"},{"location":"changelog/#Other-improvements-3","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Documentation:\nNew \"Developer documentation\" section in the manual for documenting Ferrite.jl internals and developer tools. (#611)\nFix a bug in constraint computation in Stoke's flow example. (#614)\nPerformance:\nBenchmarking infrastructure to help tracking performance changes. (#388)\nPerformance improvements for various accessor functions for MixedDofHandler. (#621)","category":"page"},{"location":"changelog/#Internal-changes-2","page":"Ferrite changelog","title":"Internal changes","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"To clarify the dof management vertices(ip), edges(ip) and faces(ip) has been deprecated in favor of vertexdof_indices(ip), edgedof_indices(ip) and facedof_indices(ip). (#581)\nDuplicate grid representation has been removed from the MixedDofHandler. (#577)","category":"page"},{"location":"changelog/#Version-0.3.12-2023-02-28","page":"Ferrite changelog","title":"Version 0.3.12 - 2023-02-28","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Added a basic show method for assemblers. (#598)","category":"page"},{"location":"changelog/#Fixed-3","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix an issue in constraint application of Symmetric-wrapped sparse matrices (i.e. obtained from create_symmatric_sparsity_pattern). In particular, apply!(K::Symmetric, f, ch) would incorrectly modify f if any of the constraints were inhomogeneous. (#592)\nProperly disable the Metis extension on Julia 1.9 instead of causing precompilation errors. (#588)\nFix adding Dirichlet boundary conditions on nodes when using MixedDofHandler. (#593, #594)\nFix accidentally slow implementation of show for Grids. (#599)\nFixes to topology functionality. (#453, #518, #455)\nFix grid coloring for cell sets with 0 or 1 cells. (#600)","category":"page"},{"location":"changelog/#Other-improvements-4","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Documentation improvements:\nSimplications and clarifications to hyperelasticity example. (#591)\nRemove duplicate docstring entry for vtk_point_data. (#602)\nUpdate documentation about initial conditions. (#601, #604)","category":"page"},{"location":"changelog/#Version-0.3.11-2023-01-17","page":"Ferrite changelog","title":"Version 0.3.11 - 2023-01-17","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Metis.jl extension for fill-reducing DoF permutation. This uses Julias new package extension mechanism (requires Julia 1.10) to support a new DoF renumbering order DofOrder.Ext{Metis}() that can be passed to renumber! to renumber DoFs using the Metis.jl library. (#393, #549)\nBlockArrays.jl extension for creating a globally blocked system matrix. create_sparsity_pattern(BlockMatrix, dh, ch; kwargs...) return a matrix that is blocked by field (requires DoFs to be (re)numbered by field, i.e. renumber!(dh, DofOrder.FieldWise())). For custom blocking it is possible to pass an uninitialized BlockMatrix with the correct block sizes (see BlockArrays.jl docs). This functionality is useful for e.g. special solvers where individual blocks need to be extracted. Requires Julia version 1.9 or above. (#567)\nNew function apply_analytical! for setting the values of the degrees of freedom for a specific field according to a spatial function f(x). (#532)\nNew cache struct CellCache to be used when iterating over the cells in a grid or DoF handler. CellCache caches nodes, coordinates, and DoFs, for the cell. The cache cc can be re-initialized for a new cell index ci by calling reinit!(cc, ci). This can be used as an alternative to CellIterator when more control over which element to loop over is needed. See documentation for CellCache for more information. (#546)\nIt is now possible to create the sparsity pattern without constrained entries (they will be zeroed out later anyway) by passing keep_constrained=false to create_sparsity_pattern. This naturally only works together with local condensation of constraints since there won't be space allocated in the global matrix for the full (i.e. \"non-condensed\") element matrix. Creating the matrix without constrained entries reduces the memory footprint, but unless a significant amount of DoFs are constrained (e.g. high mesh resolution at a boundary) the savings are negligible. (#539)","category":"page"},{"location":"changelog/#Changed-2","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"ConstraintHandler: update! is now called implicitly in close!. This was easy to miss, and somewhat of a strange requirement when solving problems without time stepping. (#459)\nThe function for computing the inhomogeneity in a Dirichlet constraint can now be specified as either f(x) or f(x, t), where x is the spatial coordinate and t the time. (#459)\nThe elements of a CellIterator are now CellCache instead of the iterator itself, which was confusing in some cases. This change does not affect typical user code. (#546)","category":"page"},{"location":"changelog/#Deprecated-2","page":"Ferrite changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Adding fields to a DoF handler with push!(dh, ...) has been deprecated in favor of add!(dh, ...). This is to make it consistent with how constraints are added to a constraint handler. (#578)","category":"page"},{"location":"changelog/#Fixed-4","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix shape_value for the linear, discontinuous Lagrange interpolation. (#553)\nFix reference_coordinate dispatch for discontinuous Lagrange interpolations. (#559)\nFix show(::Grid) for custom cell types. (#570)\nFix apply_zero!(Œîa, ch) when using inhomogeneous affine constraints (#575)","category":"page"},{"location":"changelog/#Other-improvements-5","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Internal changes defining a new global matrix/vector \"interface\". These changes make it easy to enable more array types (e.g. BlockMatrix support added in this release) and solvers in the future. (#562, #571)\nPerformance improvements:\nReduced time and memory allocations for global sparse matrix creation (Julia >= 1.10). (#563)\nDocumentation improvements:\nAdded an overview of the Examples section. (#531)\nAdded an example showing topology optimization. (#531)\nVarious typo fixes. (#574)\nFix broken links. (#583)","category":"page"},{"location":"changelog/#Version-0.3.10-2022-12-11","page":"Ferrite changelog","title":"Version 0.3.10 - 2022-12-11","text":"","category":"section"},{"location":"changelog/#Added-6","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"New functions apply_local! and apply_assemble! for applying constraints locally on the element level before assembling to the global system. (#528)\nNew functionality to renumber DoFs by fields or by components. This is useful when you need the global matrix to be blocked. (#378, #545)\nFunctionality to renumber DoFs in DofHandler and ConstraintHandler simultaneously: renumber!(dh::DofHandler, ch::ConstraintHandler, order). Previously renumbering had to be done before creating the ConstraintHandler since otherwise DoF numbers would be inconsistent. However, this was inconvenient in cases where the constraints impact the new DoF order permutation. (#542)\nThe coupling between fields can now be specified when creating the global matrix with create_sparsity_pattern by passing a Matrix{Bool}. For example, in a problem with unknowns (u, p) and corresponding test functions (v, q), if there is no coupling between p and q it is unnecessary to allocate entries in the global matrix corresponding to these DoFs. This can now be communicated to create_sparsity_pattern by passing the coupling matrix [true true; true false] in the keyword argument coupling. (#544)","category":"page"},{"location":"changelog/#Changed-3","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Runtime and allocations for application of boundary conditions in apply! and apply_zero! have been improved. As a result, the strategy keyword argument is obsolete and thus ignored. (#489)\nThe internal representation of Dirichlet boundary conditions and AffineConstraints in the ConstraintHandler have been unified. As a result, conflicting constraints on DoFs are handled more consistently: the constraint added last to the ConstraintHandler now always override any previous constraints. Conflicting constraints could previously cause problems when a DoF where prescribed by both Dirichlet and AffineConstraint. (#529)\nEntries in local matrix/vector are now ignored in the assembly procedure. This allows, for example, using a dense local matrix [a b; c d] even if no entries exist in the global matrix for the d block, i.e. in [A B; C D] the D block is zero, and these global entries might not exist in the sparse matrix. (Such sparsity patterns can now be created by create_sparsity_pattern, see #544.) (#543)","category":"page"},{"location":"changelog/#Fixed-5","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix affine constraints with prescribed DoFs in the right-hand-side. In particular, DoFs that are prescribed by just an inhomogeneity are now handled correctly, and nested affine constraints now give an error instead of silently giving the wrong result. (#530, #535)\nFixed internal inconsistency in edge ordering for 2nd order RefTetrahedron and RefCube. (#520, #523)","category":"page"},{"location":"changelog/#Other-improvements-6","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Performance improvements:\nReduced time and memory allocations in DoF distribution for MixedDofHandler. (#533)\nReduced time and memory allocations reductions in getcoordinates!. (#536)\nReduced time and memory allocations in affine constraint condensation. (#537, #541, #550)\nDocumentation improvements:\nUse :static scheduling for threaded for-loop (#534)\nRemove use of @inbounds (#547)\nUnification of create_sparsity_pattern methods to remove code duplication between DofHandler and MixedDofHandler. (#538, #540)","category":"page"},{"location":"changelog/#Version-0.3.9-2022-10-19","page":"Ferrite changelog","title":"Version 0.3.9 - 2022-10-19","text":"","category":"section"},{"location":"changelog/#Added-7","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"New higher order function interpolations for triangles (Lagrange{2,RefTetrahedron,3}, Lagrange{2,RefTetrahedron,4}, and Lagrange{2,RefTetrahedron,5}). (#482, #512)\nNew Gaussian quadrature formula for triangles up to order 15. (#514)\nAdd debug mode for working with Ferrite internals. (#524)","category":"page"},{"location":"changelog/#Changed-4","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"The default components to constrain in Dirichlet and PeriodicDirichlet have changed from component 1 to all components of the field. For scalar problems this has no effect. (#506, #509)","category":"page"},{"location":"changelog/#Version-0.3.8-2022-10-05","page":"Ferrite changelog","title":"Version 0.3.8 - 2022-10-05","text":"","category":"section"},{"location":"changelog/#Added-8","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Ferrite.jl now has a logo! (#464)\nNew keyword argument search_nneighbors::Int in PointEvalHandler for specifying how many neighboring elements to consider in the kNN search. The default is still 3 (usually sufficient). (#466)\nThe IJV-assembler now support assembling non-square matrices. (#471)\nPeriodic boundary conditions have been reworked and generalized. It now supports arbitrary relations between the mirror and image boundaries (e.g. not only translations in x/y/z direction). (#478, #481, #496, #501)","category":"page"},{"location":"changelog/#Fixed-6","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix PointEvalHandler when the first point is missing. (#466)\nFix the ordering of nodes on the face for (Quadratic)Tetrahedron cells. (#475)","category":"page"},{"location":"changelog/#Other-improvements-7","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Many improvements to the documentation. (#467, #473, #487, #494, #500)\nImproved error messages in reinit! when number of geometric base functions and number of element coordinates mismatch. (#469)\nRemove some unnecessary function parametrizations. (#503)\nRemove some unnecessary allocations in grid coloring. (#505)\nMore efficient way of creating the sparsity pattern when using AffineConstraints and/or PeriodicDirichlet. (#436)","category":"page"},{"location":"changelog/#Version-0.3.7-2022-07-05","page":"Ferrite changelog","title":"Version 0.3.7 - 2022-07-05","text":"","category":"section"},{"location":"changelog/#Fixed-7","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix tests for newer version of WriteVTK (no functional change). (#462)","category":"page"},{"location":"changelog/#Other-improvements-8","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Various improvements to the heat equation example and the hyperelasticity example in the documentation. (#460, #461)","category":"page"},{"location":"changelog/#Version-0.3.6-2022-06-30","page":"Ferrite changelog","title":"Version 0.3.6 - 2022-06-30","text":"","category":"section"},{"location":"changelog/#Fixed-8","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix a bug with L2Projection of mixed grid. (#456)","category":"page"},{"location":"changelog/#Other-improvements-9","page":"Ferrite changelog","title":"Other improvements","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Expanded manual section of Dirichlet BCs. (#458)","category":"page"},{"location":"changelog/#Version-0.3.5-2022-05-30","page":"Ferrite changelog","title":"Version 0.3.5 - 2022-05-30","text":"","category":"section"},{"location":"changelog/#Added-9","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Functionality for querying information about the grid topology (e.g. neighboring cells, boundaries, ...). (#363)","category":"page"},{"location":"changelog/#Fixed-9","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Fix application of boundary conditions when combining RHSData and affine constraints. (#431)","category":"page"},{"location":"changelog/#Version-0.3.4-2022-02-25","page":"Ferrite changelog","title":"Version 0.3.4 - 2022-02-25","text":"","category":"section"},{"location":"changelog/#Added-10","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Affine (linear) constraints between degrees-of-freedom. (#401)\nPeriodic Dirichlet boundary conditions. (#418)\nEvaluation of arbitrary quantities in FE space. (#425)","category":"page"},{"location":"changelog/#Changed-5","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Interpolation(s) and the quadrature rule are now stored as part of the CellValues structs (cv.func_interp, cv.geo_interp, and cv.qr). (#428)","category":"page"},{"location":"changelog/#Version-0.3.3-2022-02-04","page":"Ferrite changelog","title":"Version 0.3.3 - 2022-02-04","text":"","category":"section"},{"location":"changelog/#Changed-6","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Verify user input in various functions to eliminate possible out-of-bounds accesses. (#407, #411)","category":"page"},{"location":"changelog/#Version-0.3.2-2022-01-18","page":"Ferrite changelog","title":"Version 0.3.2 - 2022-01-18","text":"","category":"section"},{"location":"changelog/#Added-11","page":"Ferrite changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Support for new interpolation types: DiscontinuousLagrange, BubbleEnrichedLagrange, and CrouzeixRaviart. (#352, #392)","category":"page"},{"location":"changelog/#Changed-7","page":"Ferrite changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Julia version 1.0 is no longer supported for Ferrite versions >= 0.3.2. Use Julia version >= 1.6. (#385)\nQuadrature data for L2 projection can now be given as a matrix of size \"number of elements\" x \"number of quadrature points per element\". (#386)\nProjected values from L2 projection can now be exported directly to VTK. (#390)\nGrid coloring can now act on a subset of cells. (#402)\nVarious functions related to cell values now use traits to make it easier to extend and reuse functionality in external code. (#404)","category":"page"},{"location":"changelog/#Fixed-10","page":"Ferrite changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Ferrite changelog","title":"Ferrite changelog","text":"Exporting tensors to VTK now use correct names for the components. (#406)","category":"page"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"QuadratureRule\nFaceQuadratureRule\ngetnquadpoints(::QuadratureRule)\ngetnquadpoints(::FaceQuadratureRule, ::Int)\ngetpoints\ngetweights","category":"page"},{"location":"reference/quadrature/#Ferrite.QuadratureRule","page":"Quadrature","title":"Ferrite.QuadratureRule","text":"QuadratureRule{shape}([quad_rule_type::Symbol], order::Int)\nQuadratureRule{shape, T}([quad_rule_type::Symbol], order::Int)\n\nCreate a QuadratureRule used for integration on the refshape shape (of type AbstractRefShape). order is the order of the quadrature rule. quad_rule_type is an optional argument determining the type of quadrature rule, currently the :legendre and :lobatto rules are implemented.\n\nA QuadratureRule is used to approximate an integral on a domain by a weighted sum of function values at specific points:\n\nintlimits_Omega f(mathbfx) textd Omega approx sumlimits_q = 1^n_q f(mathbfx_q) w_q\n\nThe quadrature rule consists of n_q points in space mathbfx_q with corresponding weights w_q.\n\nIn Ferrite, the QuadratureRule type is mostly used as one of the components to create CellValues.\n\nCommon methods:\n\ngetpoints : the points of the quadrature rule\ngetweights : the weights of the quadrature rule\n\nExample:\n\njulia> qr = QuadratureRule{RefTriangle}(1)\nQuadratureRule{RefTriangle, Float64, 2}([0.5], Vec{2, Float64}[[0.33333333333333, 0.33333333333333]])\n\njulia> getpoints(qr)\n1-element Vector{Vec{2, Float64}}:\n [0.33333333333333, 0.33333333333333]\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.FaceQuadratureRule","page":"Quadrature","title":"Ferrite.FaceQuadratureRule","text":"FaceQuadratureRule{shape}([quad_rule_type::Symbol], order::Int)\nFaceQuadratureRule{shape, T}([quad_rule_type::Symbol], order::Int)\n\nCreate a FaceQuadratureRule used for integration of the faces of the refshape shape (of type AbstractRefShape). order is the order of the quadrature rule. quad_rule_type is an optional argument determining the type of quadrature rule, currently the :legendre and :lobatto rules are implemented.\n\nFaceQuadratureRule is used as one of the components to create FaceValues.\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.getnquadpoints-Tuple{QuadratureRule}","page":"Quadrature","title":"Ferrite.getnquadpoints","text":"getnquadpoints(qr::QuadratureRule)\n\nReturn the number of quadrature points in qr.\n\n\n\n\n\n","category":"method"},{"location":"reference/quadrature/#Ferrite.getnquadpoints-Tuple{FaceQuadratureRule, Int64}","page":"Quadrature","title":"Ferrite.getnquadpoints","text":"getnquadpoints(qr::FaceQuadratureRule, face::Int)\n\nReturn the number of quadrature points in qr for local face index face.\n\n\n\n\n\n","category":"method"},{"location":"reference/quadrature/#Ferrite.getpoints","page":"Quadrature","title":"Ferrite.getpoints","text":"getpoints(qr::QuadratureRule)\ngetpoints(qr::FaceQuadratureRule, face::Int)\n\nReturn the points of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{RefTriangle}(:legendre, 2);\n\njulia> getpoints(qr)\n3-element Vector{Vec{2, Float64}}:\n [0.16666666666667, 0.16666666666667]\n [0.16666666666667, 0.66666666666667]\n [0.66666666666667, 0.16666666666667]\n\n\n\n\n\n","category":"function"},{"location":"reference/quadrature/#Ferrite.getweights","page":"Quadrature","title":"Ferrite.getweights","text":"getweights(qr::QuadratureRule)\ngetweights(qr::FaceQuadratureRule, face::Int)\n\nReturn the weights of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{RefTriangle}(:legendre, 2);\n\njulia> getweights(qr)\n3-element Array{Float64,1}:\n 0.166667\n 0.166667\n 0.166667\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/grid/#Grid-and-AbstractGrid","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"","category":"section"},{"location":"reference/grid/#Grid","page":"Grid & AbstractGrid","title":"Grid","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"generate_grid\nNode\nCellIndex\nVertexIndex\nEdgeIndex\nFaceIndex\nGrid","category":"page"},{"location":"reference/grid/#Ferrite.generate_grid","page":"Grid & AbstractGrid","title":"Ferrite.generate_grid","text":"generate_grid(celltype::Cell, nel::NTuple, [left::Vec, right::Vec)\n\nReturn a Grid for a rectangle in 1, 2 or 3 dimensions. celltype defined the type of cells, e.g. Triangle or Hexahedron. nel is a tuple of the number of elements in each direction. left and right are optional endpoints of the domain. Defaults to -1 and 1 in all directions.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.Node","page":"Grid & AbstractGrid","title":"Ferrite.Node","text":"Node{dim, T}\n\nA Node is a point in space.\n\nFields\n\nx::Vec{dim,T}: stores the coordinates\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.CellIndex","page":"Grid & AbstractGrid","title":"Ferrite.CellIndex","text":"A CellIndex wraps an Int and corresponds to a cell with that number in the mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.VertexIndex","page":"Grid & AbstractGrid","title":"Ferrite.VertexIndex","text":"A VertexIndex wraps an (Int, Int) and defines a local vertex by pointing to a (cell, vert).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.EdgeIndex","page":"Grid & AbstractGrid","title":"Ferrite.EdgeIndex","text":"A EdgeIndex wraps an (Int, Int) and defines a local edge by pointing to a (cell, edge).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.FaceIndex","page":"Grid & AbstractGrid","title":"Ferrite.FaceIndex","text":"A FaceIndex wraps an (Int, Int) and defines a local face by pointing to a (cell, face).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.Grid","page":"Grid & AbstractGrid","title":"Ferrite.Grid","text":"Grid{dim, C<:AbstractCell, T<:Real} <: AbstractGrid}\n\nA Grid is a collection of Cells and Nodes which covers the computational domain, together with Sets of cells, nodes and faces. There are multiple helper structures to apply boundary conditions or define subdomains. They are gathered in the cellsets, nodesets, facesets, edgesets and vertexsets.\n\nFields\n\ncells::Vector{C}: stores all cells of the grid\nnodes::Vector{Node{dim,T}}: stores the dim dimensional nodes of the grid\ncellsets::Dict{String,Set{Int}}: maps a String key to a Set of cell ids\nnodesets::Dict{String,Set{Int}}: maps a String key to a Set of global node ids\nfacesets::Dict{String,Set{FaceIndex}}: maps a String to a Set of Set{FaceIndex} (global_cell_id, local_face_id)\nedgesets::Dict{String,Set{EdgeIndex}}: maps a String to a Set of Set{EdgeIndex} (global_cell_id, local_edge_id\nvertexsets::Dict{String,Set{VertexIndex}}: maps a String key to a Set of local vertex ids\nboundary_matrix::SparseMatrixCSC{Bool,Int}: optional, only needed by onboundary to check if a cell is on the boundary, see, e.g. Helmholtz example\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Utility-Functions","page":"Grid & AbstractGrid","title":"Utility Functions","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"getcells\ngetncells\ngetnodes\ngetnnodes\nFerrite.nnodes_per_cell\ngetcellset\ngetnodeset\ngetfaceset\ngetedgeset\ngetvertexset\ntransform_coordinates!\ngetcoordinates\ngetcoordinates!\nFerrite.get_node_coordinate","category":"page"},{"location":"reference/grid/#Ferrite.getcells","page":"Grid & AbstractGrid","title":"Ferrite.getcells","text":"getcells(grid::AbstractGrid)\ngetcells(grid::AbstractGrid, v::Union{Int,Vector{Int}}\ngetcells(grid::AbstractGrid, setname::String)\n\nReturns either all cells::Collection{C<:AbstractCell} of a <:AbstractGrid or a subset based on an Int, Vector{Int} or String. Whereas the last option tries to call a cellset of the grid. Collection can be any indexable type, for Grid it is Vector{C<:AbstractCell}.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getncells","page":"Grid & AbstractGrid","title":"Ferrite.getncells","text":"Returns the number of cells in the <:AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnodes","page":"Grid & AbstractGrid","title":"Ferrite.getnodes","text":"getnodes(grid::AbstractGrid)\ngetnodes(grid::AbstractGrid, v::Union{Int,Vector{Int}}\ngetnodes(grid::AbstractGrid, setname::String)\n\nReturns either all nodes::Collection{N} of a <:AbstractGrid or a subset based on an Int, Vector{Int} or String. The last option tries to call a nodeset of the <:AbstractGrid. Collection{N} refers to some indexable collection where each element corresponds to a Node.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnnodes","page":"Grid & AbstractGrid","title":"Ferrite.getnnodes","text":"Returns the number of nodes in the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.nnodes_per_cell","page":"Grid & AbstractGrid","title":"Ferrite.nnodes_per_cell","text":"Returns the number of nodes of the i-th cell.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcellset","page":"Grid & AbstractGrid","title":"Ferrite.getcellset","text":"getcellset(grid::AbstractGrid, setname::String)\n\nReturns all cells as cellid in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnodeset","page":"Grid & AbstractGrid","title":"Ferrite.getnodeset","text":"getnodeset(grid::AbstractGrid, setname::String)\n\nReturns all nodes as nodeid in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getfaceset","page":"Grid & AbstractGrid","title":"Ferrite.getfaceset","text":"getfaceset(grid::AbstractGrid, setname::String)\n\nReturns all faces as FaceIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getedgeset","page":"Grid & AbstractGrid","title":"Ferrite.getedgeset","text":"getedgeset(grid::AbstractGrid, setname::String)\n\nReturns all edges as EdgeIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getvertexset","page":"Grid & AbstractGrid","title":"Ferrite.getvertexset","text":"getedgeset(grid::AbstractGrid, setname::String)\n\nReturns all vertices as VertexIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.transform_coordinates!","page":"Grid & AbstractGrid","title":"Ferrite.transform_coordinates!","text":"transform_coordinates!(grid::Abstractgrid, f::Function)\n\nTransform all nodes of the grid based on some transformation function f.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcoordinates","page":"Grid & AbstractGrid","title":"Ferrite.getcoordinates","text":"getcoordinates(grid::AbstractGrid, idx::Union{Int,CellIndex})\ngetcoordinates(cache::CellCache)\n\nGet a vector with the coordinates of the cell corresponding to idx or cache\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcoordinates!","page":"Grid & AbstractGrid","title":"Ferrite.getcoordinates!","text":"getcoordinates!(x::Vector{<:Vec}, grid::AbstractGrid, idx::Union{Int,CellIndex})\ngetcoordinates!(x::Vector{<:Vec}, grid::AbstractGrid, cell::AbstractCell)\n\nMutate x to the coordinates of the cell corresponding to idx or cell.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.get_node_coordinate","page":"Grid & AbstractGrid","title":"Ferrite.get_node_coordinate","text":"get_node_coordinate(::Node)\n\nGet the value of the node coordinate.\n\n\n\n\n\nget_node_coordinate(grid::AbstractGrid, n::Int)\n\nReturn the coordinate of the nth node in grid\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Topology","page":"Grid & AbstractGrid","title":"Topology","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Ferrite.ExclusiveTopology\nFerrite.getneighborhood\nFerrite.faceskeleton\nFerrite.vertex_star_stencils\nFerrite.getstencil","category":"page"},{"location":"reference/grid/#Ferrite.ExclusiveTopology","page":"Grid & AbstractGrid","title":"Ferrite.ExclusiveTopology","text":"ExclusiveTopology(cells::Vector{C}) where C <: AbstractCell\nExclusiveTopology(grid::Grid)\n\nExclusiveTopology saves topological (connectivity/neighborhood) data of the grid. The constructor works with an AbstractCell vector for all cells that dispatch vertices, faces and in 3D edges. The struct saves the highest dimensional neighborhood, i.e. if something is connected by a face and an  edge only the face neighborhood is saved. The lower dimensional neighborhood is recomputed, if needed.\n\nFields\n\nvertex_to_cell::Vector{Set{Int}}: global vertex id to all cells containing the vertex\ncell_neighbor::Vector{EntityNeighborhood{CellIndex}}: cellid to all connected cells\nface_neighbor::Matrix{EntityNeighborhood,Int}: face_neighbor[cellid,local_face_id] -> neighboring face\nvertex_neighbor::Matrix{EntityNeighborhood,Int}: vertex_neighbor[cellid,local_vertex_id] -> neighboring vertex\nedge_neighbor::Matrix{EntityNeighborhood,Int}: edge_neighbor[cellid_local_vertex_id] -> neighboring edge\nface_skeleton::Union{Vector{FaceIndex}, Nothing}: \n\n!!! note Currently mixed-dimensional queries do not work at the moment. They will be added back later.\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.getneighborhood","page":"Grid & AbstractGrid","title":"Ferrite.getneighborhood","text":"getneighborhood(topology, grid::AbstractGrid, cellidx::CellIndex, include_self=false)\ngetneighborhood(topology, grid::AbstractGrid, faceidx::FaceIndex, include_self=false)\ngetneighborhood(topology, grid::AbstractGrid, vertexidx::VertexIndex, include_self=false)\ngetneighborhood(topology, grid::AbstractGrid, edgeidx::EdgeIndex, include_self=false)\n\nReturns all connected entities of the same type as defined by the respective topology. If include_self is true, the given entity is included in the returned list as well.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.faceskeleton","page":"Grid & AbstractGrid","title":"Ferrite.faceskeleton","text":"face_skeleton(top::ExclusiveTopology, grid::Grid) -> Vector{FaceIndex}\n\nCreates an iterateable face skeleton. The skeleton consists of FaceIndex that can be used to reinit FaceValues.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.vertex_star_stencils","page":"Grid & AbstractGrid","title":"Ferrite.vertex_star_stencils","text":"vertex_star_stencils(top::ExclusiveTopology, grid::Grid) -> Vector{Int, EntityNeighborhood{VertexIndex}}()\n\nComputes the stencils induced by the edge connectivity of the vertices.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getstencil","page":"Grid & AbstractGrid","title":"Ferrite.getstencil","text":"getstencil(top::Dict{Int, EntityNeighborhood{VertexIndex}}, grid::AbstractGrid, vertex_idx::VertexIndex) -> EntityNeighborhood{VertexIndex}\n\nGet an iterateable over the stencil members for a given local entity.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Grid-Sets-Utility","page":"Grid & AbstractGrid","title":"Grid Sets Utility","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"addcellset!\naddfaceset!\naddboundaryfaceset!\naddboundaryedgeset!\naddboundaryvertexset!\naddnodeset!","category":"page"},{"location":"reference/grid/#Ferrite.addcellset!","page":"Grid & AbstractGrid","title":"Ferrite.addcellset!","text":"addcellset!(grid::AbstractGrid, name::String, cellid::Union{Set{Int}, Vector{Int}})\naddcellset!(grid::AbstractGrid, name::String, f::function; all::Bool=true)\n\nAdds a cellset to the grid with key name. Cellsets are typically used to define subdomains of the problem, e.g. two materials in the computational domain. The DofHandler can construct different fields which live not on the whole domain, but rather on a cellset. all=true implies that f(x) must return true for all nodal coordinates x in the cell if the cell should be added to the set, otherwise it suffices that f(x) returns true for one node. \n\naddcellset!(grid, \"left\", Set((1,3))) #add cells with id 1 and 3 to cellset left\naddcellset!(grid, \"right\", x -> norm(x[1]) < 2.0 ) #add cell to cellset right, if x[1] of each cell's node is smaller than 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addfaceset!","page":"Grid & AbstractGrid","title":"Ferrite.addfaceset!","text":"addfaceset!(grid::AbstractGrid, name::String, faceid::Union{Set{FaceIndex},Vector{FaceIndex}})\naddfaceset!(grid::AbstractGrid, name::String, f::Function; all::Bool=true)\n\nAdds a faceset to the grid with key name. A faceset maps a String key to a Set of tuples corresponding to (global_cell_id, local_face_id). Facesets are used to initialize Dirichlet structs, that are needed to specify the boundary for the ConstraintHandler. all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node. \n\naddfaceset!(grid, \"right\", Set(((2,2),(4,2))) #see grid manual example for reference\naddfaceset!(grid, \"clamped\", x -> norm(x[1]) ‚âà 0.0) #see incompressible elasticity example for reference\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addboundaryfaceset!","page":"Grid & AbstractGrid","title":"Ferrite.addboundaryfaceset!","text":"addboundaryfaceset!(grid::AbstractGrid, topology::ExclusiveTopology, name::String, f::Function; all::Bool=true)\n\nAdds a boundary faceset to the grid with key name. A faceset maps a String key to a Set of tuples corresponding to (global_cell_id, local_face_id). Facesets are used to initialize Dirichlet structs, that are needed to specify the boundary for the ConstraintHandler. all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite\n\njulia> grid = generate_grid(Tetrahedron, (1,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryfaceset!(grid, topology, \"b\", x -> true);\n\njulia> grid.facesets[\"b\"]\nSet{FaceIndex} with 12 elements:\nFaceIndex((3, 1))\nFaceIndex((4, 3))\nFaceIndex((3, 3))\nFaceIndex((4, 1))\nFaceIndex((5, 1))\nFaceIndex((2, 2))\nFaceIndex((1, 4))\nFaceIndex((2, 1))\nFaceIndex((6, 1))\nFaceIndex((6, 3))\nFaceIndex((5, 3))\nFaceIndex((1, 1))\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addboundaryedgeset!","page":"Grid & AbstractGrid","title":"Ferrite.addboundaryedgeset!","text":"addboundaryedgeset!(grid::AbstractGrid, topology::ExclusiveTopology, name::String, f::Function; all::Bool=true)\n\nAdds a boundary edgeset to the grid with key name. An edgeset maps a String key to a Set of tuples corresponding to (global_cell_id, local_edge_id). all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite\n\njulia> grid = generate_grid(Tetrahedron, (1,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryedgeset!(grid, topology, \"b\", x -> true);\n\njulia> grid.edgesets[\"b\"]\nSet{EdgeIndex} with 30 elements:\nEdgeIndex((6, 6))\nEdgeIndex((2, 1))\nEdgeIndex((5, 3))\n.\n.\n.\nEdgeIndex((2, 5))\nEdgeIndex((1, 4))\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addboundaryvertexset!","page":"Grid & AbstractGrid","title":"Ferrite.addboundaryvertexset!","text":"addboundaryvertexset!(grid::AbstractGrid, topology::ExclusiveTopology, name::String, f::Function; all::Bool=true)\n\nAdds a boundary vertexset to the grid with key name. A vertexset maps a String key to a Set of tuples corresponding to (global_cell_id, local_vertex_id). all=true implies that f(x) must return true for all nodal coordinates x on the face if the face should be added to the set, otherwise it suffices that f(x) returns true for one node.\n\njulia> using Ferrite\n\njulia> grid = generate_grid(Tetrahedron, (1,1,1));\n\njulia> topology = ExclusiveTopology(grid);\n\njulia> addboundaryvertexset!(grid, topology, \"b\", x -> true);\n\njulia> grid.vertexsets[\"b\"]\nSet{VertexIndex} with 24 elements:\nVertexIndex((2, 3))\nVertexIndex((5, 2))\nVertexIndex((4, 1))\n.\n.\n.\nVertexIndex((1, 4))\nVertexIndex((4, 4))\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addnodeset!","page":"Grid & AbstractGrid","title":"Ferrite.addnodeset!","text":"addnodeset!(grid::AbstractGrid, name::String, nodeid::Union{Vector{Int},Set{Int}})\naddnodeset!(grid::AbstractGrid, name::String, f::Function)\n\nAdds a nodeset::Dict{String, Set{Int}} to the grid with key name. Has the same interface as addcellset.  However, instead of mapping a cell id to the String key, a set of node ids is returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Multithreaded-Assembly","page":"Grid & AbstractGrid","title":"Multithreaded Assembly","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"create_coloring","category":"page"},{"location":"reference/grid/#Ferrite.create_coloring","page":"Grid & AbstractGrid","title":"Ferrite.create_coloring","text":"create_coloring(g::Grid, cellset=1:getncells(g); alg::ColoringAlgorithm)\n\nCreate a coloring of the cells in grid g such that no neighboring cells have the same color. If only a subset of cells should be colored, the cells to color can be specified by cellset.\n\nReturns a vector of vectors with cell indexes, e.g.:\n\nret = [\n   [1, 3, 5, 10, ...], # cells for color 1\n   [2, 4, 6, 12, ...], # cells for color 2\n]\n\nTwo different algorithms are available, specified with the alg keyword argument:\n\nalg = ColoringAlgorithm.WorkStream (default): Three step algorithm from Turcksin et al. [1], albeit with a greedy coloring in the second step. Generally results in more colors than ColoringAlgorithm.Greedy, however the cells are more equally distributed among the colors.\nalg = ColoringAlgorithm.Greedy: greedy algorithm that works well for structured quadrilateral grids such as e.g. quadrilateral grids from generate_grid.\n\nThe resulting colors can be visualized using vtk_cell_data_colors.\n\nnote: Cell to color mapping\nIn a previous version of Ferrite this function returned a dictionary mapping cell ID to color numbers as the first argument. If you need this mapping you can create it using the following construct:colors = create_coloring(...)\ncell_colormap = Dict{Int,Int}(\n    cellid => color for (color, cellids) in enumerate(final_colors) for cellid in cellids\n)\n\nReferences\n\n[1] Turcksin et al. ACM Trans. Math. Softw. 43 (2016).\n\n\n\n\n\n","category":"function"},{"location":"topics/#Topic-guides","page":"Topic guides","title":"Topic guides","text":"","category":"section"},{"location":"topics/","page":"Topic guides","title":"Topic guides","text":"This is an overview of the topic guides.","category":"page"},{"location":"topics/","page":"Topic guides","title":"Topic guides","text":"Pages = [\n    \"fe_intro.md\",\n    \"degrees_of_freedom.md\",\n    \"assembly.md\",\n    \"boundary_conditions.md\",\n    \"constraints.md\",\n    \"grid.md\",\n    \"export.md\"\n]","category":"page"},{"location":"gallery/#Code-gallery","page":"Code gallery","title":"Code gallery","text":"","category":"section"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"This page gives an overview of the code gallery. Compared to the tutorials, these programs do not focus on teaching Ferrite, but rather focus on showing how Ferrite can be used \"in the wild\".","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"note: Contribute to the gallery!\nMost of the gallery is user contributed. If you use Ferrite, and have something you want to share, please contribute to the gallery! This could, for example, be your research code for a published paper, some interesting application, or just some nice trick.","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"","category":"page"},{"location":"gallery/#[Helmholtz-equation](helmholtz.md)","page":"Code gallery","title":"Helmholtz equation","text":"","category":"section"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Solves the Helmholtz equation on the unit square using a combination of Dirichlet and Neumann boundary conditions and the method of manufactured solutions.","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Contributed by: Kristoffer Carlsson (@KristofferC).","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"","category":"page"},{"location":"gallery/#[Nearly-incompressible-hyperelasticity](quasi_incompressible_hyperelasticity.md)","page":"Code gallery","title":"Nearly incompressible hyperelasticity","text":"","category":"section"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"This program combines the ideas from Tutorial 3: Incompressible elasticity and Tutorial 4: Hyperelasticity to construct a mixed element solving three-dimensional displacement-pressure equations.","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Contributed by: Bhavesh Shrimali (@bhaveshshrimali).","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"","category":"page"},{"location":"gallery/#[Ginzburg-Landau-model-energy-minimization](landau.md)","page":"Code gallery","title":"Ginzburg-Landau model energy minimization","text":"","category":"section"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"A basic Ginzburg-Landau model is solved. ForwardDiff.jl is used to compute the gradient and hessian of the energy function. Multi-threading is used to parallelize the assembly procedure.","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Contributed by: Louis Ponet (@louisponet).","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"","category":"page"},{"location":"gallery/#[Topology-optimization](topology_optimization.md)","page":"Code gallery","title":"Topology optimization","text":"","category":"section"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Topology optimization is shown for the bending problem by using a SIMP material model. To avoid numerical instabilities, a regularization scheme requiring the calculation of the Laplacian is imposed, which is done by using the grid topology functionalities.","category":"page"},{"location":"gallery/","page":"Code gallery","title":"Code gallery","text":"Contributed by: Mischa Blaszczyk (@blaszm).","category":"page"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/dofhandler/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Degrees of freedom (dofs) are distributed by the DofHandler.","category":"page"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"DofHandler\nSubDofHandler","category":"page"},{"location":"reference/dofhandler/#Ferrite.DofHandler","page":"Degrees of Freedom","title":"Ferrite.DofHandler","text":"DofHandler(grid::Grid)\n\nConstruct a DofHandler based on grid. Supports:\n\nGrids with or without concrete element type (E.g. \"mixed\" grids with several different element types.)\nOne or several fields, which can live on the whole domain or on subsets of the Grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Adding-fields-to-the-DofHandlers","page":"Degrees of Freedom","title":"Adding fields to the DofHandlers","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"add!(::DofHandler, ::Symbol, ::Interpolation)\nclose!(::DofHandler)","category":"page"},{"location":"reference/dofhandler/#Ferrite.add!-Tuple{DofHandler, Symbol, Interpolation}","page":"Degrees of Freedom","title":"Ferrite.add!","text":"add!(dh::DofHandler, name::Symbol, ip::Interpolation)\n\nAdd a field called name approximated by ip to the DofHandler dh.\n\nThe field is added to all cells of the underlying grid, use SubDofHandlers if the grid contains multiple cell types, or to add the field to subset of all the cells.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Ferrite.close!-Tuple{DofHandler}","page":"Degrees of Freedom","title":"Ferrite.close!","text":"close!(dh::AbstractDofHandler)\n\nCloses dh and creates degrees of freedom for each cell.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Dof-renumbering","page":"Degrees of Freedom","title":"Dof renumbering","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"renumber!\nDofOrder.FieldWise\nDofOrder.ComponentWise","category":"page"},{"location":"reference/dofhandler/#Ferrite.renumber!","page":"Degrees of Freedom","title":"Ferrite.renumber!","text":"renumber!(dh::AbstractDofHandler, order)\nrenumber!(dh::AbstractDofHandler, ch::ConstraintHandler, order)\n\nRenumber the degrees of freedom in the DofHandler and/or ConstraintHandler according to the ordering order.\n\norder can be given by one of the following options:\n\nA permutation vector perm::AbstractVector{Int} such that dof i is renumbered to perm[i].\nDofOrder.FieldWise() for renumbering dofs field wise.\nDofOrder.ComponentWise() for renumbering dofs component wise.\nDofOrder.Ext{T} for \"external\" renumber permutations, see documentation for DofOrder.Ext for details.\n\nwarning: Warning\nThe dof numbering in the DofHandler and ConstraintHandler must always be consistent. It is therefore necessary to either renumber before creating the ConstraintHandler in the first place, or to renumber the DofHandler and the ConstraintHandler together.\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.DofOrder.FieldWise","page":"Degrees of Freedom","title":"Ferrite.DofOrder.FieldWise","text":"DofOrder.FieldWise()\nDofOrder.FieldWise(target_blocks::Vector{Int})\n\nDof order passed to renumber! to renumber global dofs field wise resulting in a globally blocked system.\n\nThe default behavior is to group dofs of each field into their own block, with the same order as in the DofHandler. This can be customized by passing a vector of the same length as the total number of fields in the DofHandler (see getfieldnames(dh)) that maps each field to a \"target block\": to renumber a DofHandler with three fields :u, :v, :w such that dofs for :u and :w end up in the first global block, and dofs for :v in the second global block use DofOrder.FieldWise([1, 2, 1]).\n\nThis renumbering is stable such that the original relative ordering of dofs within each target block is maintained.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.DofOrder.ComponentWise","page":"Degrees of Freedom","title":"Ferrite.DofOrder.ComponentWise","text":"DofOrder.ComponentWise()\nDofOrder.ComponentWise(target_blocks::Vector{Int})\n\nDof order passed to renumber! to renumber global dofs component wise resulting in a globally blocked system.\n\nThe default behavior is to group dofs of each component into their own block, with the same order as in the DofHandler. This can be customized by passing a vector of length ncomponents that maps each component to a \"target block\" (see DofOrder.FieldWise for details).\n\nThis renumbering is stable such that the original relative ordering of dofs within each target block is maintained.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Common-methods","page":"Degrees of Freedom","title":"Common methods","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ndofs\nndofs_per_cell\ndof_range\ncelldofs\ncelldofs!","category":"page"},{"location":"reference/dofhandler/#Ferrite.ndofs","page":"Degrees of Freedom","title":"Ferrite.ndofs","text":"ndofs(dh::AbstractDofHandler)\n\nReturn the number of degrees of freedom in dh\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.ndofs_per_cell","page":"Degrees of Freedom","title":"Ferrite.ndofs_per_cell","text":"ndofs_per_cell(dh::AbstractDofHandler[, cell::Int=1])\n\nReturn the number of degrees of freedom for the cell with index cell.\n\nSee also ndofs.\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.dof_range","page":"Degrees of Freedom","title":"Ferrite.dof_range","text":"dof_range(sdh::SubDofHandler, field_idx::Int)\ndof_range(sdh::SubDofHandler, field_name::Symbol)\ndof_range(dh:DofHandler, field_name::Symbol)\n\nReturn the local dof range for a given field. The field can be specified by its name or index, where field_idx represents the index of a field within a SubDofHandler and field_idxs is a tuple of the SubDofHandler-index within the DofHandler and the field_idx.\n\nnote: Note\nThe dof_range of a field can vary between different SubDofHandlers. Therefore, it is advised to use the field_idxs or refer to a given SubDofHandler directly in case several SubDofHandlers exist. Using the field_name will always refer to the first occurence of field within the DofHandler.\n\nExample:\n\njulia> grid = generate_grid(Triangle, (3, 3))\nGrid{2, Triangle, Float64} with 18 Triangle cells and 16 nodes\n\njulia> dh = DofHandler(grid); add!(dh, :u, 3); add!(dh, :p, 1); close!(dh);\n\njulia> dof_range(dh, :u)\n1:9\n\njulia> dof_range(dh, :p)\n10:12\n\njulia> dof_range(dh, (1,1)) # field :u\n1:9\n\njulia> dof_range(dh.subdofhandlers[1], 2) # field :p\n10:12\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.celldofs","page":"Degrees of Freedom","title":"Ferrite.celldofs","text":"celldofs(dh::AbstractDofHandler, i::Int)\n\nReturn a vector with the degrees of freedom that belong to cell i.\n\nSee also celldofs!.\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.celldofs!","page":"Degrees of Freedom","title":"Ferrite.celldofs!","text":"celldofs!(global_dofs::Vector{Int}, dh::AbstractDofHandler, i::Int)\n\nStore the degrees of freedom that belong to cell i in global_dofs.\n\nSee also celldofs.\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Grid-iterators","page":"Degrees of Freedom","title":"Grid iterators","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"CellCache\nCellIterator\nFaceCache\nFaceIterator\nInterfaceCache\nInterfaceIterator","category":"page"},{"location":"reference/dofhandler/#Ferrite.CellCache","page":"Degrees of Freedom","title":"Ferrite.CellCache","text":"CellCache(grid::Grid)\nCellCache(dh::AbstractDofHandler)\n\nCreate a cache object with pre-allocated memory for the nodes, coordinates, and dofs of a cell. The cache is updated for a new cell by calling reinit!(cache, cellid) where cellid::Int is the cell id.\n\nStruct fields of CellCache\n\ncc.nodes :: Vector{Int}: global node ids\ncc.coords :: Vector{<:Vec}: node coordinates\ncc.dofs :: Vector{Int}: global dof ids (empty when constructing the cache from a grid)\n\nMethods with CellCache\n\nreinit!(cc, i): reinitialize the cache for cell i\ncellid(cc): get the cell id of the currently cached cell\ngetnodes(cc): get the global node ids of the cell\ngetcoordinates(cc): get the coordinates of the cell\ncelldofs(cc): get the global dof ids of the cell\nreinit!(fev, cc): reinitialize CellValues or FaceValues\n\nSee also CellIterator.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.CellIterator","page":"Degrees of Freedom","title":"Ferrite.CellIterator","text":"CellIterator(grid::Grid, cellset=1:getncells(grid))\nCellIterator(dh::AbstractDofHandler, cellset=1:getncells(dh))\n\nCreate a CellIterator to conveniently iterate over all, or a subset, of the cells in a grid. The elements of the iterator are CellCaches which are properly reinit!ialized. See CellCache for more details.\n\nLooping over a CellIterator, i.e.:\n\nfor cc in CellIterator(grid, cellset)\n    # ...\nend\n\nis thus simply convenience for the following equivalent snippet:\n\ncc = CellCache(grid)\nfor idx in cellset\n    reinit!(cc, idx)\n    # ...\nend\n\nwarning: Warning\nCellIterator is stateful and should not be used for things other than for-looping (e.g. broadcasting over, or collecting the iterator may yield unexpected results).\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.FaceCache","page":"Degrees of Freedom","title":"Ferrite.FaceCache","text":"FaceCache(grid::Grid)\nFaceCache(dh::AbstractDofHandler)\n\nCreate a cache object with pre-allocated memory for the nodes, coordinates, and dofs of a cell suitable for looping over faces in a grid. The cache is updated for a new face by calling reinit!(cache, fi::FaceIndex).\n\nMethods with fc::FaceCache\n\nreinit!(fc, fi): reinitialize the cache for face fi::FaceIndex\ncellid(fc): get the current cellid (faceindex(fc)[1])\ngetnodes(fc): get the global node ids of the cell\ngetcoordinates(fc): get the coordinates of the cell\ncelldofs(fc): get the global dof ids of the cell\nreinit!(fv, fc): reinitialize FaceValues\n\nSee also FaceIterator.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.FaceIterator","page":"Degrees of Freedom","title":"Ferrite.FaceIterator","text":"FaceIterator(gridordh::Union{Grid,AbstractDofHandler}, faceset::Set{FaceIndex})\n\nCreate a FaceIterator to conveniently iterate over the faces in faceset. The elements of the iterator are FaceCaches which are properly reinit!ialized. See FaceCache for more details.\n\nLooping over a FaceIterator, i.e.:\n\nfor fc in FaceIterator(grid, faceset)\n    # ...\nend\n\nis thus simply convenience for the following equivalent snippet: ```julia fc = FaceCache(grid) for faceindex in faceset     reinit!(fc, faceindex)     # ... end\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.InterfaceCache","page":"Degrees of Freedom","title":"Ferrite.InterfaceCache","text":"InterfaceCache(grid::Grid)\nInterfaceCache(dh::AbstractDofHandler)\n\nCreate a cache object with pre-allocated memory for the nodes, coordinates, and dofs of an interface. The cache is updated for a new cell by calling reinit!(cache, face_a, face_b) where face_a::FaceIndex and face_b::FaceIndex are the two interface faces.\n\nStruct fields of InterfaceCache\n\nic.a :: FaceCache: face cache for the first face of the interface\nic.b :: FaceCache: face cache for the second face of the interface\nic.dofs :: Vector{Int}: global dof ids for the interface (union of ic.a.dofs and ic.b.dofs)\n\nMethods with InterfaceCache\n\nreinit!(cache::InterfaceCache, face_a::FaceIndex, face_b::FaceIndex): reinitialize the cache for a new interface\ninterfacedofs(ic): get the global dof ids of the interface\n\nSee also InterfaceIterator.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.InterfaceIterator","page":"Degrees of Freedom","title":"Ferrite.InterfaceIterator","text":"InterfaceIterator(grid::Grid, [topology::ExclusiveTopology])\nInterfaceIterator(dh::AbstractDofHandler, [topology::ExclusiveTopology])\n\nCreate an InterfaceIterator to conveniently iterate over all the interfaces in a grid. The elements of the iterator are InterfaceCaches which are properly reinit!ialized. See InterfaceCache for more details. Looping over an InterfaceIterator, i.e.:\n\nfor ic in InterfaceIterator(grid, topology)\n    # ...\nend\n\nis thus simply convenience for the following equivalent snippet for grids of dimensions > 1:\n\nic = InterfaceCache(grid, topology)\nfor face in topology.face_skeleton\n    neighborhood = topology.face_face_neighbor[face[1], face[2]]\n    isempty(neighborhood) && continue\n    neighbor_face = neighborhood[1]\n    reinit!(ic, face, neighbor_face)\n    # ...\nend\n\nwarning: Warning\nInterfaceIterator is stateful and should not be used for things other than for-looping (e.g. broadcasting over, or collecting the iterator may yield unexpected results).\n\n\n\n\n\n","category":"type"},{"location":"devdocs/dofhandler/#dofhandler-interpolations","page":"Dof Handler","title":"Dof Handler","text":"","category":"section"},{"location":"devdocs/dofhandler/#Type-definitions","page":"Dof Handler","title":"Type definitions","text":"","category":"section"},{"location":"devdocs/dofhandler/","page":"Dof Handler","title":"Dof Handler","text":"Dof handlers are subtypes of AbstractDofhandler{sdim}, i.e. they are parametrized by the spatial dimension. Internally a helper struct InterpolationInfo is utilized to enforce type stability during dof distribution, because the interpolations are not available as concrete types.","category":"page"},{"location":"devdocs/dofhandler/","page":"Dof Handler","title":"Dof Handler","text":"Ferrite.InterpolationInfo\nFerrite.PathOrientationInfo\nFerrite.SurfaceOrientationInfo","category":"page"},{"location":"devdocs/dofhandler/#Ferrite.InterpolationInfo","page":"Dof Handler","title":"Ferrite.InterpolationInfo","text":"InterpolationInfo\n\nGathers all the information needed to distribute dofs for a given interpolation. Note that this cache is of the same type no matter the interpolation: the purpose is to make dof-distribution type-stable.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/dofhandler/#Ferrite.PathOrientationInfo","page":"Dof Handler","title":"Ferrite.PathOrientationInfo","text":"PathOrientationInfo\n\nOrientation information for 1D entities.\n\nThe orientation for 1D entities is defined by the indices of the grid nodes associated to the vertices. To give an example, the oriented path\n\n1 ---> 2\n\nis called regular, indicated by regular=true, while the oriented path\n\n2 ---> 1\n\nis called inverted, indicated by regular=false.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/dofhandler/#Ferrite.SurfaceOrientationInfo","page":"Dof Handler","title":"Ferrite.SurfaceOrientationInfo","text":"SurfaceOrientationInfo\n\nOrientation information for 2D entities. Such an entity can be  possibly flipped (i.e. the defining vertex order is reverse to the  spanning vertex order) and the vertices can be rotated against each other. Take for example the faces\n\n1---2 2---3\n| A | | B |\n4---3 1---4\n\nwhich are rotated against each other by 90¬∞ (shift index is 1) or the faces\n\n1---2 2---1\n| A | | B |\n4---3 3---4\n\nwhich are flipped against each other. Any combination of these can happen.  The combination to map this local face to the defining face is encoded with this data structure via rotate circ flip where the rotation is indiced by the shift index.     !!!NOTE TODO implement me.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/dofhandler/#Internal-API","page":"Dof Handler","title":"Internal API","text":"","category":"section"},{"location":"devdocs/dofhandler/","page":"Dof Handler","title":"Dof Handler","text":"The main entry point for dof distribution is __close!.","category":"page"},{"location":"devdocs/dofhandler/","page":"Dof Handler","title":"Dof Handler","text":"Ferrite.__close!\nFerrite.get_grid\nFerrite.find_field(dh::DofHandler, field_name::Symbol)\nFerrite._close_subdofhandler!\nFerrite._distribute_dofs_for_cell!\nFerrite.permute_and_push!\nFerrite.cross_element_coupling!\nFerrite._add_cross_coupling","category":"page"},{"location":"devdocs/dofhandler/#Ferrite.__close!","page":"Dof Handler","title":"Ferrite.__close!","text":"__close!(dh::DofHandler)\n\nInternal entry point for dof distribution.\n\nDofs are distributed as follows: For the DofHandler each SubDofHandler is visited in the order they were added. For each field in the SubDofHandler create dofs for the cell. This means that dofs on a particular cell will be numbered in groups for each field, so first the dofs for field 1 are distributed, then field 2, etc. For each cell dofs are first distributed on its vertices, then on the interior of edges (if applicable), then on the  interior of faces (if applicable), and finally on the cell interior. The entity ordering follows the geometrical ordering found in vertices, faces and edges.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite.get_grid","page":"Dof Handler","title":"Ferrite.get_grid","text":"get_grid(dh::AbstractDofHandler)\n\nAccess some grid representation for the dof handler.\n\nnote: Note\nThis API function is currently not well-defined. It acts as the interface between  distributed assembly and assembly on a single process, because most parts of the functionality can be handled by only acting on the locally owned cell set.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite.find_field-Tuple{DofHandler, Symbol}","page":"Dof Handler","title":"Ferrite.find_field","text":"find_field(dh::DofHandler, field_name::Symbol)::NTuple{2,Int}\n\nReturn the index of the field with name field_name in a DofHandler. The index is a NTuple{2,Int}, where the 1st entry is the index of the SubDofHandler within which the field was found and the 2nd entry is the index of the field within the SubDofHandler.\n\nnote: Note\nAlways finds the 1st occurence of a field within DofHandler.\n\nSee also: find_field(sdh::SubDofHandler, field_name::Symbol), _find_field(sdh::SubDofHandler, field_name::Symbol).\n\n\n\n\n\n","category":"method"},{"location":"devdocs/dofhandler/#Ferrite._close_subdofhandler!","page":"Dof Handler","title":"Ferrite._close_subdofhandler!","text":"_close_subdofhandler!(dh::DofHandler{sdim}, sdh::SubDofHandler, sdh_index::Int, nextdof::Int, vertexdicts, edgedicts, facedicts) where {sdim}\n\nMain entry point to distribute dofs for a single SubDofHandler on its subdomain.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite._distribute_dofs_for_cell!","page":"Dof Handler","title":"Ferrite._distribute_dofs_for_cell!","text":"_distribute_dofs_for_cell!(dh::DofHandler{sdim}, cell::AbstractCell, ip_info::InterpolationInfo, nextdof::Int, vertexdict, edgedict, facedict) where {sdim}\n\nMain entry point to distribute dofs for a single cell.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite.permute_and_push!","page":"Dof Handler","title":"Ferrite.permute_and_push!","text":"permute_and_push!\n\nFor interpolations with more than one interior dof per edge it may be necessary to adjust the dofs. Since dofs are (initially) enumerated according to the local edge direction there can be a direction mismatch with the neighboring element. For example, in the following nodal interpolation example, with three interior dofs on each edge, the initial pass have distributed dofs 4, 5, 6 according to the local edge directions:\n\n+-----------+\n|     A     |\n+--4--5--6->+    local edge on element A\n\n ---------->     global edge\n\n+<-6--5--4--+    local edge on element B\n|     B     |\n+-----------+\n\nFor most scalar-valued interpolations we can simply compensate for this by reversing the numbering on all edges that do not match the global edge direction, i.e. for the edge on element B in the example.\n\nIn addition, we also have to preverse the ordering at each dof location.\n\nFor more details we refer to Scroggs et al. [3] as we follow the methodology described therein.\n\nReferences\n\n[3] Scroggs et al. ACM Trans. Math. Softw. 48 (2022).\n\n\n\n\n\n!!!NOTE TODO implement me.\n\nFor more details we refer to [1] as we follow the methodology described therein.\n\n[1] Scroggs, M. W., Dokken, J. S., Richardson, C. N., & Wells, G. N. (2022).      Construction of arbitrary order finite element degree-of-freedom maps on      polygonal and polyhedral cell meshes. ACM Transactions on Mathematical      Software (TOMS), 48(2), 1-23.\n\n!!!TODO citation via software.\n\n!!!TODO Investigate if we can somehow pass the interpolation into this function in a typestable way.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite.cross_element_coupling!","page":"Dof Handler","title":"Ferrite.cross_element_coupling!","text":"cross_element_coupling!(dh::DofHandler, topology::ExclusiveTopology, sym::Bool, keep_constrained::Bool, couplings::Union{AbstractVector{<:AbstractMatrix{Bool}},Nothing}, cnt::Int, I::Vector{Int}, J::Vector{Int})\n\nMutates I, J to account for cross-element coupling by calling _add_cross_coupling. Returns the updated value of cnt.\n\nUsed internally for sparsity patterns with cross-element coupling.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/dofhandler/#Ferrite._add_cross_coupling","page":"Dof Handler","title":"Ferrite._add_cross_coupling","text":"_add_cross_coupling(coupling_sdh, dof_i, dof_j, cell_field_dofs, neighbor_field_dofs, i, j, sym, keep_constrained, ch, cnt, I, J)\n\nHelper function used to mutate I and J to add cross-element coupling.\n\n\n\n\n\n","category":"function"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"using Ferrite","category":"page"},{"location":"topics/degrees_of_freedom/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The distribution and numbering of degrees of freedom (dofs) are handled by the DofHandler. The DofHandler will be used to query information about the dofs. For example we can obtain the dofs for a particular cell, which we need when assembling the system.","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The DofHandler is based on the grid. Here we create a simple grid with Triangle cells, and then create a DofHandler based on the grid","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"grid = generate_grid(Triangle, (20, 20))\ndh = DofHandler(grid)\n# hide","category":"page"},{"location":"topics/degrees_of_freedom/#Fields","page":"Degrees of Freedom","title":"Fields","text":"","category":"section"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Before we can distribute the dofs we need to specify fields. A field is simply the unknown function(s) we are solving for. To add a field we need a name (a Symbol) and we also need to specify number of components for the field. Here we add a vector field :u (2 components for a 2D problem) and a scalar field :p.","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"add!(dh, :u, Lagrange{2,RefTetrahedron,1}()^2)\nadd!(dh, :p, Lagrange{2,RefTetrahedron,1}())\n# hide","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Finally, when we have added all the fields, we have to close! the DofHandler. When the DofHandler is closed it will traverse the grid and distribute all the dofs for the fields we added.","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"close!(dh)","category":"page"},{"location":"topics/degrees_of_freedom/#Specifying-interpolation-for-a-field","page":"Degrees of Freedom","title":"Specifying interpolation for a field","text":"","category":"section"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"In the example above we did not specify which interpolation should be used for our fields :u and :p. By default iso-parametric elements will be used meaning that the interpolation that matches the grid will be used ‚Äì for a linear grid a linear interpolation will be used etc. It is sometimes useful to separate the grid interpolation from the interpolation that is used to approximate our fields (e.g. sub- and super-parametric elements).","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"We can specify which interpolation that should be used for the approximation when we add the fields to the dofhandler. For example, here we add our vector field :u with a quadratic interpolation, and our :p field with a linear approximation.","category":"page"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"dh = DofHandler(grid) # hide\nadd!(dh, :u, Lagrange{2,RefTetrahedron,2}()^2)\nadd!(dh, :p, Lagrange{2,RefTetrahedron,1}())\n# hide","category":"page"},{"location":"topics/degrees_of_freedom/#Ordering-of-Dofs","page":"Degrees of Freedom","title":"Ordering of Dofs","text":"","category":"section"},{"location":"topics/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ordered in the same order as we add to dofhandler nodes -> (edges ->) faces -> cells","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"#Ferrite.jl","page":"Home","title":"Ferrite.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for Ferrite.jl! Ferrite is a finite element toolbox that provides functionalities to implement finite element analysis in Julia. The aim is to be i) general, ii) performant, and iii) to keep mathematical abstractions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nPlease help improve this documentation ‚Äì if something confuses you, chances are you're not alone. It's easy to do as you read along: just click on the \"Edit on GitHub\" link at the top of each page, and then edit the files directly in your browser. Your changes will be vetted by developers before becoming permanent, so don't worry about whether you might say something wrong. See also Contributing to Ferrite for more details.","category":"page"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This high level view of the documentation structure will help you find what you are looking for. The document is organized as follows[1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials are thoroughly documented examples which guides you through the process of solving partial differential equations using Ferrite.\nTopic guides contains more in-depth explanations and discussions about finite element programming concepts and ideas, and specifically how these are realized in Ferrite.\nReference contains the technical API reference of functions and methods (e.g. the documentation strings).\nHow-to guides will guide you through the steps involved in addressing common tasks and use-cases. These usually build on top of the tutorials and thus assume basic knowledge of how Ferrite works.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: The organization of the document follows the Di√°taxis Framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition there is a Code gallery, with user contributed example programs, and the Developer documentation, for documentation of Ferrite internal code.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a new user of Ferrite it is suggested to start working with the tutorials before using Ferrite to tackle the specific equation you ultimately want to solve. The tutorials start with explaining the basic concepts and then increase in complexity. Understanding the first tutorial program, solving the heat equation, is essential in order to understand how Ferrite works. Already this rather simple program discusses many of the important concepts. See the tutorials overview for suggestion on how to progress to more advanced usage.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about Ferrite it is suggested to use the #ferrite-fem channel on the Julia Slack, or the #Ferrite.jl stream on Zulip. Alternatively you can use the discussion forum on the GitHub repository.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use Ferrite you first need to install Julia, see https://julialang.org/ for details. Installing Ferrite can then be done from the Pkg REPL; press ] at the julia> promp to enter pkg> mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Ferrite","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install Ferrite and all necessary dependencies. Press backspace to get back to the julia> prompt. (See the documentation for Pkg, Julia's package manager, for more help regarding package installation and project management.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, to load Ferrite, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now all set to start using Ferrite!","category":"page"},{"location":"#Contributing-to-Ferrite","page":"Home","title":"Contributing to Ferrite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ferrite is still under active development. If you find a bug, or have ideas for improvements, you are encouraged to interact with the developers on the Ferrite GitHub repository. There is also a thorough contributor guide which can be found in CONTRIBUTING.md.","category":"page"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Pages = [\"boundary_conditions.md\"]","category":"page"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ConstraintHandler\nDirichlet\nPeriodicDirichlet\ncollect_periodic_faces\ncollect_periodic_faces!\nadd!\nclose!\nupdate!\napply!\napply_zero!\napply_local!\napply_assemble!\nget_rhs_data\napply_rhs!\nFerrite.RHSData","category":"page"},{"location":"reference/boundary_conditions/#Ferrite.ConstraintHandler","page":"Boundary Conditions","title":"Ferrite.ConstraintHandler","text":"ConstraintHandler\n\nCollection of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.Dirichlet","page":"Boundary Conditions","title":"Ferrite.Dirichlet","text":"Dirichlet(u::Symbol, ‚àÇŒ©::Set, f::Function, components=nothing)\n\nCreate a Dirichlet boundary condition on u on the ‚àÇŒ© part of the boundary. f is a function of the form f(x) or f(x, t) where x is the spatial coordinate and t is the current time, and returns the prescribed value. components specify the components of u that are prescribed by this condition. By default all components of u are prescribed.\n\nFor example, here we create a Dirichlet condition for the :u field, on the faceset called ‚àÇŒ© and the value given by the sin function:\n\nExamples\n\n# Obtain the faceset from the grid\n‚àÇŒ© = getfaceset(grid, \"boundary-1\")\n\n# Prescribe scalar field :s on ‚àÇŒ© to sin(t)\ndbc = Dirichlet(:s, ‚àÇŒ©, (x, t) -> sin(t))\n\n# Prescribe all components of vector field :v on ‚àÇŒ© to 0\ndbc = Dirichlet(:v, ‚àÇŒ©, x -> 0 * x)\n\n# Prescribe component 2 and 3 of vector field :v on ‚àÇŒ© to [sin(t), cos(t)]\ndbc = Dirichlet(:v, ‚àÇŒ©, (x, t) -> [sin(t), cos(t)], [2, 3])\n\nDirichlet boundary conditions are added to a ConstraintHandler which applies the condition via apply! and/or apply_zero!.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.PeriodicDirichlet","page":"Boundary Conditions","title":"Ferrite.PeriodicDirichlet","text":"PeriodicDirichlet(u::Symbol, face_mapping, components=nothing)\nPeriodicDirichlet(u::Symbol, face_mapping, R::AbstractMatrix, components=nothing)\nPeriodicDirichlet(u::Symbol, face_mapping, f::Function, components=nothing)\n\nCreate a periodic Dirichlet boundary condition for the field u on the face-pairs given in face_mapping. The mapping can be computed with collect_periodic_faces. The constraint ensures that degrees-of-freedom on the mirror face are constrained to the corresponding degrees-of-freedom on the image face. components specify the components of u that are prescribed by this condition. By default all components of u are prescribed.\n\nIf the mapping is not aligned with the coordinate axis (e.g. rotated) a rotation matrix R should be passed to the constructor. This matrix rotates dofs on the mirror face to the image face. Note that this is only applicable for vector-valued problems.\n\nTo construct an inhomogeneous periodic constraint it is possible to pass a function f. Note that this is currently only supported when the periodicity is aligned with the coordinate axes.\n\nSee the manual section on Periodic boundary conditions for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.collect_periodic_faces","page":"Boundary Conditions","title":"Ferrite.collect_periodic_faces","text":"collect_periodic_faces(grid::Grid, mset, iset, transform::Union{Function,Nothing}=nothing; tol=1e-12)\n\nMatch all mirror faces in mset with a corresponding image face in iset. Return a dictionary which maps each mirror face to a image face. The result can then be passed to PeriodicDirichlet.\n\nmset and iset can be given as a String (an existing face set in the grid) or as a Set{FaceIndex} directly.\n\nBy default this function looks for a matching face in the directions of the coordinate system. For other types of periodicities the transform function can be used. The transform function is applied on the coordinates of the image face, and is expected to transform the coordinates to the matching locations in the mirror set.\n\nThe keyword tol specifies the tolerence (i.e. distance and deviation in face-normals)  between a image-face and mirror-face, for them to be considered matched.\n\nSee also: collect_periodic_faces!, PeriodicDirichlet.\n\n\n\n\n\ncollect_periodic_faces(grid::Grid, all_faces::Union{Set{FaceIndex},String,Nothing}=nothing; tol=1e-12)\n\nSplit all faces in all_faces into image and mirror sets. For each matching pair, the face located further along the vector (1, 1, 1) becomes the image face.\n\nIf no set is given, all faces on the outer boundary of the grid (i.e. all faces that do not have a neighbor) is used.\n\nSee also: collect_periodic_faces!, PeriodicDirichlet.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.collect_periodic_faces!","page":"Boundary Conditions","title":"Ferrite.collect_periodic_faces!","text":"collect_periodic_faces!(face_map::Vector{PeriodicFacePair}, grid::Grid, mset, iset, transform::Union{Function,Nothing}; tol=1e-12)\n\nSame as collect_periodic_faces but adds all matches to the existing face_map.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.add!","page":"Boundary Conditions","title":"Ferrite.add!","text":"add!(sdh::SubDofHandler, name::Symbol, ip::Interpolation)\n\nAdd a field called name approximated by ip to the SubDofHandler sdh.\n\n\n\n\n\nadd!(dh::DofHandler, name::Symbol, ip::Interpolation)\n\nAdd a field called name approximated by ip to the DofHandler dh.\n\nThe field is added to all cells of the underlying grid, use SubDofHandlers if the grid contains multiple cell types, or to add the field to subset of all the cells.\n\n\n\n\n\nadd!(ch::ConstraintHandler, ac::AffineConstraint)\n\nAdd the AffineConstraint to the ConstraintHandler.\n\n\n\n\n\nadd!(ch::ConstraintHandler, dbc::Dirichlet)\n\nAdd a Dirichlet boundary condition to the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.close!","page":"Boundary Conditions","title":"Ferrite.close!","text":"close!(dh::AbstractDofHandler)\n\nCloses dh and creates degrees of freedom for each cell.\n\n\n\n\n\nclose!(ch::ConstraintHandler)\n\nClose and finalize the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.update!","page":"Boundary Conditions","title":"Ferrite.update!","text":"update!(ch::ConstraintHandler, time::Real=0.0)\n\nUpdate time-dependent inhomogeneities for the new time. This calls f(x) or f(x, t) when applicable, where f is the function(s) corresponding to the constraints in the handler, to compute the inhomogeneities.\n\nNote that this is called implicitly in close!(::ConstraintHandler).\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply!","page":"Boundary Conditions","title":"Ferrite.apply!","text":"apply!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)\n\nAdjust the matrix K and right hand side rhs to account for the Dirichlet boundary conditions specified in ch such that K \\ rhs gives the expected solution.\n\nnote: Note\napply!(K, rhs, ch) essentially calculatesrhs[free] = rhs[free] - K[constrained, constrained] * a[constrained]where a[constrained] are the inhomogeneities. Consequently, the sign of rhs matters (in contrast with apply_zero!).\n\napply!(v::AbstractVector, ch::ConstraintHandler)\n\nApply Dirichlet boundary conditions and affine constraints, specified in ch, to the solution vector v.\n\nExamples\n\nK, f = assemble_system(...) # Assemble system\napply!(K, f, ch)            # Adjust K and f to account for boundary conditions\nu = K \\ f                   # Solve the system, u should be \"approximately correct\"\napply!(u, ch)               # Explicitly make sure bcs are correct\n\nnote: Note\nThe last operation is not strictly necessary since the boundary conditions should already be fulfilled after apply!(K, f, ch). However, solvers of linear systems are not exact, and thus apply!(u, ch) can be used to make sure the boundary conditions are fulfilled exactly.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_zero!","page":"Boundary Conditions","title":"Ferrite.apply_zero!","text":"apply_zero!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)\n\nAdjust the matrix K and the right hand side rhs to account for prescribed Dirichlet boundary conditions and affine constraints such that du = K \\ rhs gives the expected  result (e.g. du zero for all prescribed degrees of freedom).\n\napply_zero!(v::AbstractVector, ch::ConstraintHandler)\n\nZero-out values in v corresponding to prescribed degrees of freedom and update values  prescribed by affine constraints, such that if a fulfills the constraints, a ¬± v also will.\n\nThese methods are typically used in e.g. a Newton solver where the increment, du, should be prescribed to zero even for non-homogeneouos boundary conditions.\n\nSee also: apply!.\n\nExamples\n\nu = un + Œîu                 # Current guess\nK, g = assemble_system(...) # Assemble residual and tangent for current guess\napply_zero!(K, g, ch)       # Adjust tangent and residual to take prescribed values into account\nŒîŒîu = K \\ g                # Compute the (negative) increment, prescribed values are \"approximately\" zero\napply_zero!(ŒîŒîu, ch)        # Make sure values are exactly zero\nŒîu .-= ŒîŒîu                  # Update current guess\n\nnote: Note\nThe last call to apply_zero! is only strictly necessary for affine constraints.  However, even if the Dirichlet boundary conditions should be fulfilled after  apply!(K, g, ch), solvers of linear systems are not exact.  apply!(ŒîŒîu, ch) can be used to make sure the values for the prescribed degrees of freedom are fulfilled exactly.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_local!","page":"Boundary Conditions","title":"Ferrite.apply_local!","text":"apply_local!(\n    local_matrix::AbstractMatrix, local_vector::AbstractVector,\n    global_dofs::AbstractVector, ch::ConstraintHandler;\n    apply_zero::Bool = false\n)\n\nSimilar to apply! but perform condensation of constrained degrees-of-freedom locally in local_matrix and local_vector before they are to be assembled into the global system.\n\nWhen the keyword argument apply_zero is true all inhomogeneities are set to 0 (cf. apply! vs apply_zero!).\n\nThis method can only be used if all constraints are \"local\", i.e. no constraint couples with dofs outside of the element dofs (global_dofs) since condensation of such constraints requires writing to entries in the global matrix/vector. For such a case, apply_assemble! can be used instead.\n\nNote that this method is destructive since it, by definition, modifies local_matrix and local_vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_assemble!","page":"Boundary Conditions","title":"Ferrite.apply_assemble!","text":"apply_assemble!(\n    assembler::AbstractSparseAssembler, ch::ConstraintHandler,\n    global_dofs::AbstractVector{Int},\n    local_matrix::AbstractMatrix, local_vector::AbstractVector;\n    apply_zero::Bool = false\n)\n\nAssemble local_matrix and local_vector into the global system in assembler by first doing constraint condensation using apply_local!.\n\nThis is similar to using apply_local! followed by assemble! with the advantage that non-local constraints can be handled, since this method can write to entries of the global matrix and vector outside of the indices in global_dofs.\n\nWhen the keyword argument apply_zero is true all inhomogeneities are set to 0 (cf. apply! vs apply_zero!).\n\nNote that this method is destructive since it modifies local_matrix and local_vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.get_rhs_data","page":"Boundary Conditions","title":"Ferrite.get_rhs_data","text":"get_rhs_data(ch::ConstraintHandler, A::SparseMatrixCSC) -> RHSData\n\nReturns the needed RHSData for apply_rhs!.\n\nThis must be used when the same stiffness matrix is reused for multiple steps, for example when timestepping, with different non-homogeneouos Dirichlet boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_rhs!","page":"Boundary Conditions","title":"Ferrite.apply_rhs!","text":"apply_rhs!(data::RHSData, f::AbstractVector, ch::ConstraintHandler, applyzero::Bool=false)\n\nApplies the boundary condition to the right-hand-side vector without modifying the stiffness matrix.\n\nSee also: get_rhs_data.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.RHSData","page":"Boundary Conditions","title":"Ferrite.RHSData","text":"RHSData\n\nStores the constrained columns and mean of the diagonal of stiffness matrix A.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Initial-conditions","page":"Boundary Conditions","title":"Initial conditions","text":"","category":"section"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"apply_analytical!","category":"page"},{"location":"reference/boundary_conditions/#Ferrite.apply_analytical!","page":"Boundary Conditions","title":"Ferrite.apply_analytical!","text":"apply_analytical!(\n    a::AbstractVector, dh::AbstractDofHandler, fieldname::Symbol, \n    f::Function, cellset=1:getncells(get_grid(dh)))\n\nApply a solution f(x) by modifying the values in the degree of freedom vector a pertaining to the field fieldname for all cells in cellset. The function f(x) are given the spatial coordinate of the degree of freedom. For scalar fields, f(x)::Number, and for vector fields with dimension dim, f(x)::Vec{dim}.\n\nThis function can be used to apply initial conditions for time dependent problems.\n\nnote: Note\nThis function only works for standard nodal finite element interpolations when the function value at the (algebraic) node is equal to the corresponding degree of freedom value. This holds for e.g. Lagrange and Serendipity interpolations, including sub- and superparametric elements.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/interpolations/#reference-interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"Interpolation\ngetnbasefunctions\ngetdim\ngetrefshape\ngetorder","category":"page"},{"location":"reference/interpolations/#Ferrite.Interpolation","page":"Interpolation","title":"Ferrite.Interpolation","text":"Interpolation{ref_shape, order}()\n\nAbstract type for interpolations defined on ref_shape (see AbstractRefShape). order corresponds to the order of the interpolation. The interpolation is used to define shape functions to interpolate a function between nodes.\n\nThe following interpolations are implemented:\n\nLagrange{RefLine,1}\nLagrange{RefLine,2}\nLagrange{RefQuadrilateral,1}\nLagrange{RefQuadrilateral,2}\nLagrange{RefQuadrilateral,3}\nLagrange{RefTriangle,1}\nLagrange{RefTriangle,2}\nLagrange{RefTriangle,3}\nLagrange{RefTriangle,4}\nLagrange{RefTriangle,5}\nBubbleEnrichedLagrange{RefTriangle,1}\nCrouzeixRaviart{RefTriangle, 1}\nLagrange{RefHexahedron,1}\nLagrange{RefHexahedron,2}\nLagrange{RefTetrahedron,1}\nLagrange{RefTetrahedron,2}\nLagrange{RefPrism,1}\nLagrange{RefPrism,2}\nLagrange{RefPyramid,1}\nLagrange{RefPyramid,2}\nSerendipity{RefQuadrilateral,2}\nSerendipity{RefHexahedron,2}\n\nExamples\n\njulia> ip = Lagrange{RefTriangle, 2}()\nLagrange{RefTriangle, 2}()\n\njulia> getnbasefunctions(ip)\n6\n\n\n\n\n\n","category":"type"},{"location":"reference/interpolations/#Ferrite.getnbasefunctions","page":"Interpolation","title":"Ferrite.getnbasefunctions","text":"Ferrite.getnbasefunctions(ip::Interpolation)\n\nReturn the number of base functions for the interpolation ip.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getdim","page":"Interpolation","title":"Ferrite.getdim","text":"Ferrite.getdim(::Interpolation)\n\nReturn the dimension of the reference element for a given interpolation.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getrefshape","page":"Interpolation","title":"Ferrite.getrefshape","text":"Ferrite.getrefshape(::Interpolation)::AbstractRefShape\n\nReturn the reference element shape of the interpolation.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getorder","page":"Interpolation","title":"Ferrite.getorder","text":"Ferrite.getorder(::Interpolation)\n\nReturn order of the interpolation.\n\n\n\n\n\n","category":"function"}]
}
